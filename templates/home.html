<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.11.1/font/bootstrap-icons.min.css"
        rel="stylesheet">

    <!-- Prism.js CSS for styling -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <!-- Prism.js JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-xml-doc.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-lua.min.js"></script>
    <!-- Add more languages as needed -->
    <!-- C/C++ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-glsl.min.js"></script>

    <style>
        body {
            background-color: #0f0f23;
            color: #cccccc;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        .main-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .content-area {
            flex: 1;
            display: flex;
            min-height: 0;
        }

        .tree-panel {
            width: 400px;
            min-width: 250px;
            max-width: 500px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            resize: horizontal;
            overflow: hidden;
        }

        .tree-header {
            background: linear-gradient(90deg, #0f3460 0%, #16537e 100%);
            padding: 15px;
            border-bottom: 1px solid #333;
        }

        .tree-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .preview-panel {
            flex: 1;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .preview-header {
            background: linear-gradient(90deg, #16537e 0%, #0f3460 100%);
            padding: 15px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: between;
            align-items: center;
        }

        .preview-content {
            flex: 1;
            padding: 20px;
            overflow: auto;
        }

        .preview-xac {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 70vh;
            overflow: hidden;
        }


        .info-panel {
            width: 350px;
            min-width: 300px;
            max-width: 500px;
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            resize: horizontal;
            overflow: hidden;
        }

        .info-header {
            background: linear-gradient(90deg, #0f3460 0%, #16537e 100%);
            padding: 15px;
            border-bottom: 1px solid #333;
        }

        .info-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        /* Tree Styles */
        .tree-item {
            padding: 8px 12px;
            margin: 2px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: normal;
            /* allow wrapping */
            word-break: break-word;
            /* break long words if needed */
            overflow-wrap: break-word;
            /* fallback for older browsers */
        }

        .tree-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(3px);
        }

        .tree-item.selected {
            background: linear-gradient(90deg, #4a90e2 0%, #357abd 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(74, 144, 226, 0.3);
        }

        .tree-item.folder {
            color: #4a90e2;
            font-weight: 500;
        }

        .tree-item.file {
            color: #ffffff;
            padding-left: 24px;
        }

        .tree-item i {
            font-size: 14px;
            width: 16px;
            text-align: center;
        }

        /* Search Box */
        .search-box {
            position: sticky;
            top: 0;
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
        }

        .search-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #333;
            border-radius: 8px;
            color: #cccccc;
            width: 100%;
            padding: 8px 12px;
        }

        .search-input:focus {
            border-color: #4a90e2;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
            outline: none;
            background: rgba(255, 255, 255, 0.15);
        }

        /* IES Table Styles */
        .ies-table {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .ies-table table {
            margin: 0;
        }

        .ies-table th {
            background: linear-gradient(90deg, #16537e 0%, #0f3460 100%);
            color: white;
            padding: 12px;
            font-weight: 600;
            border: none;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .ies-table td {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            color: #ffffff;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
        }

        .ies-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        /* Statistics Cards */
        .stat-card {
            background: linear-gradient(135deg, rgba(74, 144, 226, 0.1) 0%, rgba(53, 122, 189, 0.1) 100%);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            transition: transform 0.2s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(74, 144, 226, 0.2);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4a90e2;
        }

        .stat-value-wrap {
            word-break: break-all;
            /* Break long text */
            white-space: normal;
            /* Wrap lines normally */
            overflow-wrap: anywhere;
            /* Modern alternative to break anywhere if needed */
        }


        .stat-label {
            color: #b0b0b0;
            font-size: 0.9rem;
        }

        /* Tree Collapse Styles */
        .tree-children {
            margin-left: 20px;
            overflow: hidden;
            transform-origin: top;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out, background-color 0.3s ease-out;
            transform: scaleY(0);
            opacity: 0;
        }

        /* Expanded subfolders */
        .tree-children.expanded {
            transform: scaleY(1);
            opacity: 1;
            background-color: rgba(38, 56, 108, 0.6);
            /* slightly darker */
            border-radius: 4px;
            padding-left: 10px;
        }



        .file-icon {
            color: #666;
        }

        .file-icon.ies {
            color: #f39c12;
        }

        .file-icon.xml {
            color: #e74c3c;
        }

        .file-icon.lua {
            color: #9b59b6;
        }

        .file-icon.png,
        .file-icon.jpg,
        .file-icon.jpeg,
        .file-icon.bmp,
        .file-icon.tga {
            color: #2ecc71;
        }

        .file-icon.tok {
            color: gold;
        }

        .file-icon.\33 dworld {
            color: #2ecc71;
        }


        /* Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid rgba(74, 144, 226, 0.3);
            border-top: 3px solid #4a90e2;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #357abd 0%, #2e6da4 100%);
        }

        /* Navigation Header */
        .navbar {
            background: linear-gradient(90deg, #0f3460 0%, #16537e 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .navbar-brand {
            color: white !important;
            font-weight: bold;
            font-size: 1.3rem;
        }

        /* Breadcrumb */
        .breadcrumb-container {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 15px;
            border-bottom: 1px solid #333;
        }

        .breadcrumb {
            margin: 0;
            background: none;
        }

        .breadcrumb-item a {
            color: #4a90e2;
            text-decoration: none;
        }

        .breadcrumb-item a:hover {
            color: #357abd;
        }

        .breadcrumb-item.active {
            color: #ffffff;
        }

        /* Version Selector */
        .version-selector {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #333;
            border-radius: 6px;
            color: #cccccc;
            padding: 5px 10px;
            font-size: 0.9rem;
        }

        .version-selector:focus {
            border-color: #4a90e2;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
            outline: none;
        }
    </style>
</head>

<body>


    <div class="main-container">
        <!-- Navigation Header -->
        <nav class="navbar navbar-expand-lg">
            <div class="container-fluid">
                <a class="navbar-brand" href="/home">
                    <i class="bi bi-archive"></i>
                    Tree of Savior Archive Viewer
                </a>
                <div class="d-flex align-items-center text-light">
                    <small class="me-3">
                        <i class="bi bi-files"></i>
                        {{ count_unique }} files
                    </small>
                    <small>
                        <i class="bi bi-hdd"></i>
                        Ready
                    </small>
                </div>
            </div>
        </nav>

        <div class="content-area">
            <!-- Left Panel - File Tree -->
            <div class="tree-panel">
                <div class="tree-header">
                    <h6 class="mb-0">
                        <i class="bi bi-folder-open"></i>
                        File Browser
                    </h6>
                </div>

                <div class="search-box input-group">
                    <input type="text" class="form-control search-input  bg-dark text-light"
                        placeholder="Search files..." id="fileSearch">
                    <button class="btn btn-primary" id="searchBtn">
                        <i class="bi bi-search"></i>
                    </button>
                </div>


                <div class="tree-content" id="fileTree">
                    <div class="loading">
                        <div class="spinner"></div>
                        Loading file tree...
                    </div>
                </div>
            </div>

            <!-- Middle Panel - Preview -->
            <div class="preview-panel">
                <div class="preview-header">
                    <div>
                        <h6 class="mb-0" id="previewTitle">
                            <i class="bi bi-eye"></i>
                            Preview
                        </h6>
                        <div class="breadcrumb-container">
                            <nav aria-label="breadcrumb">
                                <ol class="breadcrumb" id="breadcrumb">
                                    <li class="breadcrumb-item active">Select a file to preview</li>
                                </ol>
                            </nav>
                        </div>
                    </div>
                    <div id="versionControls" style="display: none;">
                        <select class="version-selector" id="versionSelect">
                            <option value="0">Version 1</option>
                        </select>
                    </div>
                </div>

                <div class="preview-content" id="previewContent">
                    <div class="text-center text-light mt-5">
                        <i class="bi bi-file-earmark" style="font-size: 4rem; opacity: 0.3;"></i>
                        <h5 class="mt-3">No file selected</h5>
                        <p>Select a file from the tree to preview its contents</p>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Information -->
            <div class="info-panel">
                <div class="info-header">
                    <h6 class="mb-0">
                        <i class="bi bi-info-circle"></i>
                        Information
                    </h6>
                </div>

                <div class="info-content">

                    <!-- File Information Panel -->
                    <div id="fileInfo" style="display: none;">
                        <h6 class="mt-4 mb-3">File Details</h6>
                        <div id="fileDetails"></div>
                    </div>


                    <!-- General Stats -->
                    <h6 class="mt-4 mb-3">General Stats</h6>
                    <div class="stat-card">
                        <div class="stat-value">{{ count_unique }}</div>
                        <div class="stat-label">Unique Files</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ count_duplicated }}</div>
                        <div class="stat-label">Duplicated Files</div>
                    </div>


                    <!-- File Size Stats -->
                    <h6 class="mt-4 mb-3">File Size (Compressed)</h6>
                    <div class="stat-card">
                        <div class="stat-value">{{ compressed_lowest }}</div>
                        <div class="stat-label">Lowest</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ compressed_avg }}</div>
                        <div class="stat-label">Average</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ compressed_highest }}</div>
                        <div class="stat-label">Highest</div>
                    </div>

                    <h6 class="mt-4 mb-3">File Size (Uncompressed)</h6>
                    <div class="stat-card">
                        <div class="stat-value">{{ uncompressed_lowest }}</div>
                        <div class="stat-label">Lowest</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ uncompressed_avg }}</div>
                        <div class="stat-label">Average</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ uncompressed_highest }}</div>
                        <div class="stat-label">Highest</div>
                    </div>

                    <!-- Duplicate Statistics -->
                    <h6 class="mt-4 mb-3">Duplicate Statistics</h6>
                    <div class="stat-card">
                        <div class="stat-value">{{ duplicates_xac + duplicates_xsm + duplicates_xsmtime + duplicates_xpm
                            + duplicates_dds }}</div>
                        <div class="stat-label">Total Duplicates</div>
                    </div>

                    <div class="row g-2">
                        <div class="col-6">
                            <div class="stat-card">
                                <div class="stat-value">{{ duplicates_xac }}</div>
                                <div class="stat-label">XAC</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="stat-card">
                                <div class="stat-value">{{ duplicates_xsm }}</div>
                                <div class="stat-label">XSM</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="stat-card">
                                <div class="stat-value">{{ duplicates_xsmtime }}</div>
                                <div class="stat-label">XSM Time</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="stat-card">
                                <div class="stat-value">{{ duplicates_xpm }}</div>
                                <div class="stat-label">XPM</div>
                            </div>
                        </div>
                        <div class="col-12">
                            <div class="stat-card">
                                <div class="stat-value">{{ duplicates_dds }}</div>
                                <div class="stat-label">DDS</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/js/bootstrap.bundle.min.js"></script>
    <script>
        class ArchiveViewer {
            constructor() {
                this.currentFolder = "";
                this.currentFile = null;
                this.fileVersions = [];
                this.selectedVersion = 0;
                this.init();
            }

            init() {
                this.loadRootFolders();
                this.setupEventListeners();
            }

            setupEventListeners() {

                // Version selector
                document.getElementById('versionSelect').addEventListener('change', (e) => {
                    this.selectedVersion = parseInt(e.target.value);

                    // Load the preview
                    this.loadFilePreview(this.currentFile, this.selectedVersion);

                    // Update file info for the selected version
                    const fileInfo = this.fileVersions?.[this.selectedVersion] || this.fileVersions?.[0];
                    this.updateFileDetails(fileInfo);
                });

                document.getElementById('searchBtn').addEventListener('click', () => {
                    const query = document.getElementById('fileSearch').value;
                    this.searchFiles(query);
                });

                // Optional: also trigger search on Enter key
                document.getElementById('fileSearch').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault(); // prevents accidental form submit if inside a form
                        const query = e.target.value;
                        this.searchFiles(query);
                    }
                });


            }



            async loadRootFolders() {
                try {
                    const response = await fetch('/api/folder/shallow?folder_name=');
                    if (!response.ok) throw new Error('Failed to load root folders');

                    const data = await response.json();
                    this.renderFolderTree(data);
                } catch (error) {
                    document.getElementById('fileTree').innerHTML = `
                        <div class="text-danger p-3">
                            <i class="bi bi-exclamation-triangle"></i>
                            Error loading file tree: ${error.message}
                        </div>
                    `;
                }
            }

            async loadFolder(folderName) {
                try {
                    const response = await fetch(`/api/folder/shallow?folder_name=${encodeURIComponent(folderName)}`);
                    if (!response.ok) throw new Error('Failed to load folder');

                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error loading folder:', error);
                    return null;
                }
            }

            renderFolderTree(data, parentElement = null) {
                const container = parentElement || document.getElementById('fileTree');
                container.innerHTML = '';


                // Sort subfolders naturally, case-insensitive
                const sortedSubfolders = [...data.subfolders].sort((a, b) =>
                    a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })
                );

                // Sort files naturally, case-insensitive
                const sortedFiles = [...data.files].sort((a, b) =>
                    a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })
                );


                // Render sorted subfolders
                sortedSubfolders.forEach(folder => {
                    const folderElement = this.createFolderElement(folder, data.folder_name);
                    container.appendChild(folderElement);
                });

                // Render sorted files
                sortedFiles.forEach(file => {
                    const fileElement = this.createFileElement(file, data.folder_name);
                    container.appendChild(fileElement);
                });
            }

            createFolderElement(folderName, parentPath) {
                const element = document.createElement('div');
                element.className = 'tree-item folder';
                element.innerHTML = `
                    <i class="bi bi-folder"></i>
                    <span>${folderName}</span>
                `;

                let childContainer = null;
                let isExpanded = false;

                element.addEventListener('click', async () => {
                    if (isExpanded) {
                        // Collapse folder
                        isExpanded = false;
                        element.querySelector('i').className = 'bi bi-folder';
                        if (childContainer) {
                            childContainer.classList.remove('expanded');
                            childContainer.classList.add('collapsed');
                            setTimeout(() => {
                                childContainer.remove();
                                childContainer = null;
                            }, 300);
                        }
                    } else {
                        // Expand folder
                        isExpanded = true;
                        element.querySelector('i').className = 'bi bi-folder-open';

                        const fullPath = parentPath ? `${parentPath}/${folderName}` : folderName;
                        const folderData = await this.loadFolder(fullPath);

                        if (folderData) {
                            // Create container for children
                            childContainer = document.createElement('div');
                            childContainer.className = 'tree-children collapsed';



                            // Sort subfolders naturally, case-insensitive
                            const sortedSubfolders = [...folderData.subfolders].sort((a, b) =>
                                a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })
                            );

                            // Sort files naturally, case-insensitive
                            const sortedFiles = [...folderData.files].sort((a, b) =>
                                a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })
                            );


                            // Add sorted subfolders
                            sortedSubfolders.forEach(subfolder => {
                                const subfolderElement = this.createFolderElement(subfolder, fullPath);
                                childContainer.appendChild(subfolderElement);
                            });

                            // Add sorted files
                            sortedFiles.forEach(file => {
                                const fileElement = this.createFileElement(file, fullPath);
                                childContainer.appendChild(fileElement);
                            });

                            // Insert after current folder
                            element.parentNode.insertBefore(childContainer, element.nextSibling);

                            // Trigger expansion animation
                            setTimeout(() => {
                                childContainer.classList.remove('collapsed');
                                childContainer.classList.add('expanded');
                            }, 10);
                        }
                    }
                });

                return element;
            }

            createFileElement(fileName, parentPath) {
                const element = document.createElement('div');
                element.className = 'tree-item file';

                const ext = fileName.split('.').pop().toLowerCase();
                const iconClass = this.getFileIcon(ext);

                element.innerHTML = `
                    <i class="bi ${iconClass} file-icon ${ext}"></i>
                    <span>${fileName}</span>
                `;
                element.addEventListener('click', () => {
                    document.querySelectorAll('.tree-item.selected').forEach(item => {
                        item.classList.remove('selected');
                    });

                    element.classList.add('selected');

                    const fullPath = parentPath ? `${parentPath}/${fileName}` : fileName;
                    this.selectedVersion = 0;

                    // Just call loadFileInfo (it already updates details + preview)
                    this.loadFileInfo(fullPath);
                });


                return element;
            }

            getFileIcon(extension) {
                const icons = {
                    'ies': 'bi-table',
                    'xml': 'bi-code-slash',
                    'skn': 'bi-code-slash',
                    '3deffect': 'bi-code-slash',
                    '3dprop': 'bi-code-slash',
                    '3dworld': 'bi-code-slash',
                    '3drender': 'bi-code-slash',
                    'fx': 'bi-code-slash',
                    'fxh': 'bi-code-slash',
                    'x': 'bi-code-slash',
                    'sani': 'bi-code-slash',
                    'effect': 'bi-code-slash',
                    'sprbin': 'bi-code-slash',
                    'lua': 'bi-file-code',
                    'png': 'bi-image',
                    'jpg': 'bi-image',
                    'jpeg': 'bi-image',
                    'bmp': 'bi-image',
                    'tok': 'bi-image',
                    '3dworld': 'bi-map-fill',
                    'tga': 'bi-image',
                    'txt': 'bi-file-text'
                };
                return icons[extension] || 'bi-file-earmark';
            }

            async loadFileInfo(filePath) {
                try {
                    this.currentFile = filePath;

                    // Load file versions
                    const response = await fetch(`/api/file/fullpath?full_path=${encodeURIComponent(filePath)}`);
                    if (!response.ok) throw new Error('File not found');

                    this.fileVersions = await response.json();
                    this.updateVersionSelector();
                    this.updateBreadcrumb(filePath);
                    const fileInfo = this.fileVersions?.[this.selectedVersion] || this.fileVersions?.[0];
                    this.updateFileDetails(fileInfo);
                    this.loadFilePreview(filePath, 0);

                } catch (error) {
                    console.error('Error loading file info:', error);
                    this.showError('Failed to load file information');
                }
            }

            updateVersionSelector() {
                const selector = document.getElementById('versionSelect');
                const controls = document.getElementById('versionControls');

                if (this.fileVersions.length > 1) {
                    controls.style.display = 'block';
                    selector.innerHTML = this.fileVersions.map((version, index) =>
                        `<option value="${index}">Version ${index + 1}</option>`
                    ).join('');
                } else {
                    controls.style.display = 'none';
                }
            }

            updateBreadcrumb(filePath) {
                const breadcrumb = document.getElementById('breadcrumb');
                const parts = filePath.split('/');

                breadcrumb.innerHTML = parts.map((part, index) => {
                    if (index === parts.length - 1) {
                        return `<li class="breadcrumb-item active">${part}</li>`;
                    } else {
                        return `<li class="breadcrumb-item"><a href="#">${part}/</a></li>`;
                    }
                }).join('');
            }

            updateFileDetails(fileInfo) {
                document.getElementById('fileInfo').style.display = 'block';

                const details = document.getElementById('fileDetails');
                details.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">Container</div>
                        <div class="stat-value stat-value-wrap" style="font-size: 1rem;">${fileInfo.container_name}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Compressed Size</div>
                        <div class="stat-value" style="font-size: 1rem;">${this.formatBytes(fileInfo.file_size_compressed)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Uncompressed Size</div>
                        <div class="stat-value" style="font-size: 1rem;">${this.formatBytes(fileInfo.file_size_uncompressed)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">CRC32</div>
                        <div class="stat-value" style="font-size: 1rem;">${fileInfo.crc32.toString(16).toUpperCase()}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">File Path</div>
                        <div class="stat-value stat-value-wrap" style="font-size: 1rem;">
                            ${fileInfo.file_path.toString()}
                        </div>
                    </div>
                    <div class="stat-card d-flex justify-content-center align-items-center" style="height: 100px;">
                        <a href="/api/file/download?path=${encodeURIComponent(this.currentFile)}&version=${this.selectedVersion || 0}" 
                        class="btn btn-primary">
                        <i class="bi bi-download"></i>
                            Download File Raw
                        </a>
                    </div>

                `;
            }

            async loadFilePreview(filePath, version = 0) {
                const previewContent = document.getElementById('previewContent');
                previewContent.classList.remove("preview-xac"); // revert
                previewContent.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        Loading preview...
                    </div>
                `;

                try {
                    const response = await fetch(`/api/file/preview?path=${encodeURIComponent(filePath)}&version=${version}`);

                    if (!response.ok) throw new Error('Failed to load preview');

                    const contentType = response.headers.get('content-type');
                    const extension = filePath.split('.').pop().toLowerCase();

                    if (contentType.includes('application/json') && extension === 'ies') {
                        // Only treat JSON as IES if the file extension is .ies
                        const iesData = await response.json();
                        this.renderIESTable(iesData);
                    } else if (contentType.includes('audio') && extension === 'mp3') {
                        const mp3Data = await response.blob();
                        this.renderMP3Audio(mp3Data);
                    } else if (contentType.includes('application/json') && extension === '3dworld') {
                        //const xacDataWorld = await response.json();
                        //this.renderXACModelWorld(xacDataWorld);
                    }
                    else if (contentType.includes('application/json') && extension === 'xac') {
                        const xacData = await response.json();
                        this.renderXACModel(xacData);
                    } else if (contentType.includes('text/plain')) {
                        // Text file - render as code
                        let text = await response.text(); // use let, not const

                        const extension = filePath.split('.').pop().toLowerCase();
                        if (extension === 'json') {
                            try {
                                text = JSON.stringify(JSON.parse(text), null, 2); // 2-space indent
                            } catch (e) {
                                // fallback if JSON is invalid
                            }
                        }

                        this.renderTextContent(text, filePath);
                    } else if (contentType.includes('image/') && (filePath.toLowerCase().endsWith('.dds') || contentType.includes('dds'))) {
                        // DDS: fetch as ArrayBuffer and render with WebGL compressed texture support
                        const arrayBuffer = await response.arrayBuffer();
                        this.renderDDSContent(arrayBuffer);
                    } else if (contentType.includes('image/')) {
                        // Image file - render as image
                        const blob = await response.blob();
                        this.renderImageContent(blob);
                    } else if (contentType.includes('font/')) {
                        // Font file - render as text
                        const blob = await response.blob();
                        this.renderFontContent(blob);
                    } else {
                        // Binary file - show download option
                        this.renderBinaryContent(filePath, version);
                    }

                } catch (error) {
                    this.showError('Failed to load file preview');
                }
            }


            renderFontContent(blob) {
                const previewContent = document.getElementById('previewContent');
                previewContent.innerHTML = ''; // clear previous content

                const fontUrl = URL.createObjectURL(blob);
                const fontName = 'PreviewFont';

                // Create @font-face style
                const style = document.createElement('style');
                style.innerHTML = `
        @font-face {
            font-family: '${fontName}';
            src: url('${fontUrl}');
        }
    `;
                document.head.appendChild(style);

                // Create stat-card container
                const container = document.createElement('div');
                container.className = 'stat-card';
                container.style.cssText = `
        padding: 20px;
        background: linear-gradient(135deg, rgba(74, 144, 226, 0.1) 0%, rgba(53, 122, 189, 0.1) 100%);
        border: 1px solid rgba(74, 144, 226, 0.3);
        border-radius: 12px;
        max-width: 100%;
        height: 70vh;
        display: flex;
        flex-direction: row;
        gap: 10px;
        box-sizing: border-box;
        overflow: hidden;
    `;

                // Create textarea for typing (left)
                const textarea = document.createElement('textarea');
                textarea.value = `The quick brown fox jumps over the lazy dog\nType multiple lines here...`;
                textarea.style.cssText = `
        width: 50%;
        height: 100%;
        padding: 8px;
        font-size: 1.2rem;
        resize: none;
        box-sizing: border-box;
        overflow: auto;
    `;

                // Create preview div (right)
                const preview = document.createElement('div');
                preview.textContent = textarea.value;
                preview.style.cssText = `
        font-family: ${fontName};
        font-size: 2rem;
        border: 1px solid #ccc;
        padding: 20px;
        width: 50%;
        height: 100%;
        overflow: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        box-sizing: border-box;
    `;

                // Update preview live
                const onInput = () => {
                    preview.textContent = textarea.value;
                };
                textarea.addEventListener('input', onInput);

                // Append elements
                container.appendChild(textarea);
                container.appendChild(preview);
                previewContent.appendChild(container);

                // Cleanup
                this.currentCleanup = () => {
                    textarea.removeEventListener('input', onInput);
                    previewContent.innerHTML = '';
                    if (style.parentNode) style.parentNode.removeChild(style);
                    URL.revokeObjectURL(fontUrl);
                };
            }




            renderBinaryContent(filePath, version = 0, maxBytes = 1024) {

                const previewContent = document.getElementById('previewContent');
                const fileName = filePath.split('/').pop();

                let abortController = new AbortController(); // for possible cancellation

                fetch(`/api/file/preview?path=${encodeURIComponent(filePath)}&version=${version}`, {
                    signal: abortController.signal
                })
                    .then(res => {
                        if (!res.ok) throw new Error('Failed to load file');
                        return res.arrayBuffer();
                    })
                    .then(buffer => {
                        const bytes = new Uint8Array(buffer);
                        const length = Math.min(bytes.length, maxBytes);

                        // Convert to hex + ASCII string
                        let hex = '';
                        for (let i = 0; i < length; i += 16) {
                            const row = bytes.slice(i, i + 16);
                            const hexBytes = Array.from(row).map(b => b.toString(16).padStart(2, '0')).join(' ');
                            const ascii = Array.from(row).map(b => (b >= 32 && b <= 126 ? String.fromCharCode(b) : '.')).join('');
                            hex += hexBytes.padEnd(16 * 3) + '  ' + ascii + '\n';
                        }

                        previewContent.innerHTML = `
<div class="bg-dark p-3 rounded" style="background-color: rgba(0,0,0,0.5); overflow: auto;">
    <pre style="color: #ffffff; font-family: monospace; margin: 0;">${hex}</pre>
    <p style="color: orange; font-size: 0.9rem; margin-top: 0.5rem;">
        ${fileName} â€” showing maximum ${length} byte(s)
    </p>
</div>`;
                    })
                    .catch(err => {
                        previewContent.innerHTML = `
<div class="bg-dark p-4 rounded text-center" 
     style="background-color: rgba(0,0,0,0.5); display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 1rem;">
    <div style="font-size: 4rem; color: orange;">&#9888;</div>
    <p style="color: orange; font-size: 1.2rem; margin: 0;">Cannot preview binary file</p>
    <p style="color: #ffffff; font-weight: bold; margin: 0;">${fileName}</p>
</div>`;
                        console.error(err);
                    });

                // Cleanup
                this.currentCleanup = () => {
                    // abort any ongoing fetch
                    abortController.abort();
                    previewContent.innerHTML = ""; // clear DOM
                    abortController = null;
                };

            }


            // Create a reusable fallback white texture (create once per GL context)
            createFallbackTexture = (gl) => {
                // cache on the gl object to reuse across calls
                if (gl._fallbackWhiteTexture) return gl._fallbackWhiteTexture;

                const tex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tex);
                const whitePixel = new Uint8Array([255, 255, 255, 255]);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0,
                    gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                gl._fallbackWhiteTexture = tex;
                return tex;
            }

            normalizeTextureName(texPath) {
                if (!texPath) return null;

                // change extension .tga/.png/.bmp â†’ .dds
                const name = texPath.replace(/\.(tga|png|bmp|jpg|jpeg|dds)$/i, ".dds");

                return name.toLowerCase();
            }

            async findTexturePath(texPath) {
                const fileName = this.normalizeTextureName(texPath);
                if (!fileName) return null;

                const url = `/api/file/search?file_name=${encodeURIComponent(fileName)}`;
                console.log("[Search] GET", url);

                const resp = await fetch(url);
                if (!resp.ok) {
                    console.warn("[Search] Failed:", resp.status);
                    return null;
                }

                const data = await resp.json();
                if (!data.found_files || data.found_files.length === 0) {
                    console.warn("[Search] No matches for", fileName);
                    return null;
                }

                // Always take result index 0
                const entry = data.found_files[0];

                return {
                    path: entry.file_path,
                    version: entry.version
                };
            }


            // Load texture from server â€” detect image vs DDS with detailed logging
            loadTextureFromServer = async (gl, path, version = 0) => {

                console.log("===========================================");
                console.log("[TextureLoader] START loadTextureFromServer");
                console.log(`[Input] path = ${path}`);
                console.log(`[Input] version = ${version}`);

                // ðŸ”¥ FIX: await the async search
                const textureData = await this.findTexturePath(path);

                if (!textureData) {
                    console.warn("[TextureLoader] Texture not found on server:", path);
                    return null;
                }

                console.log("[TextureLoader] Resolved:", textureData);

                const url = `/api/file/download?path=${encodeURIComponent(textureData.path)}&version=${textureData.version}`;
                console.log(`[URL] Fetching: ${url}`);

                try {
                    console.log("[Fetch] Sending request...");
                    const resp = await fetch(url);

                    console.log(`[Fetch] Status: ${resp.status} ${resp.statusText}`);

                    if (!resp.ok) {
                        console.error("[Fetch] Response NOT OK");
                        throw new Error(`Failed to download file: ${resp.status}`);
                    }

                    console.log("[Fetch] OK, reading blob...");
                    const blob = await resp.blob();

                    console.log(`[Blob] MIME Type: ${blob.type}`);
                    console.log(`[Blob] Size: ${blob.size} bytes`);

                    const arrayBuffer = await blob.arrayBuffer();
                    console.log(`[ArrayBuffer] Loaded. ByteLength: ${arrayBuffer.byteLength}`);

                    if (arrayBuffer.byteLength === 0) {
                        console.error("[ArrayBuffer] ERROR: File is empty (0 bytes).");
                        throw new Error("Empty file received from server");
                    }

                    // Optional DDS detection
                    const isDDS =
                        blob.type.includes("dds") ||
                        (arrayBuffer.byteLength >= 4 &&
                            new Uint8Array(arrayBuffer, 0, 4).every((v, i, arr) =>
                                i < 4 ? ["D".charCodeAt(0), "D".charCodeAt(0), "S".charCodeAt(0), " ".charCodeAt(0)][i] === v : true
                            ));

                    console.log(`[Detect] DDS format = ${isDDS}`);

                    console.log("[Texture] Passing ArrayBuffer to loadTexture...");
                    const result = await this.loadTexture(gl, arrayBuffer);

                    console.log("[Texture] SUCCESS â€” texture loaded.");
                    console.log("===========================================");

                    return result;

                } catch (err) {
                    console.error("[ERROR] loadTextureFromServer FAILED:");
                    console.error(err);

                    console.log("[Texture] Using fallback texture instead.");
                    console.log("===========================================");

                    return this.createFallbackTexture(gl);
                }
            };


            // Robust loadTexture with detailed logging and full DDS support (mipmaps, DX10)
            loadTexture = async (gl, source) => {
                console.log("=== loadTexture START ===");
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);

                // placeholder magenta pixel while we load real data
                const placeholder = new Uint8Array([255, 0, 255, 255]);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, placeholder);

                function applyTextureParams() {
                    // Use non-mipmap filters by default; if we upload mipmaps later we will change them
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                }

                // Helper to log WebGL errors
                function logGLError(stage) {
                    const err = gl.getError();
                    if (err !== gl.NO_ERROR) {
                        console.error(`[WebGL][${stage}] gl.getError() -> 0x${err.toString(16)}`);
                        return true;
                    }
                    return false;
                }

                // Helper to setup from HTMLImageElement
                function setupTextureFromImage(img) {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                    applyTextureParams();
                    console.log("[Texture] Image element uploaded.");
                }

                // If source is ArrayBuffer -> assume DDS or uncompressed pixel buffer
                if (source instanceof ArrayBuffer) {
                    console.log("[Texture] source is ArrayBuffer; attempting DDS parse.");
                    try {
                        // alignment
                        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

                        const DDS_MAGIC = 0x20534444; // "DDS "
                        const DDS_DX10 = 0x30315844;  // "DX10"
                        const dds = new DataView(source);
                        const magic = dds.getUint32(0, true);
                        if (magic !== DDS_MAGIC) throw new Error('Not a DDS file (magic mismatch)');

                        const height = dds.getUint32(12, true);
                        const width = dds.getUint32(16, true);
                        const mipMapCount = Math.max(1, dds.getUint32(28, true) || 1);
                        const fourCC = dds.getUint32(84, true);
                        console.log(`[DDS] width=${width}, height=${height}, mipMapCount=${mipMapCount}, fourCC=0x${fourCC.toString(16)}`);

                        // convert fourCC to string for logging
                        function fourCCToString(cc) {
                            return String.fromCharCode(
                                cc & 0xff,
                                (cc >> 8) & 0xff,
                                (cc >> 16) & 0xff,
                                (cc >> 24) & 0xff
                            );
                        }
                        console.log(`[DDS] fourCC string = "${fourCCToString(fourCC)}"`);

                        let offset = 128; // header size
                        let formatKey = null;
                        let blockSize = 0;
                        let uncompressed = false;
                        let bytesPerPixel = 4;

                        if (fourCC === DDS_DX10) {
                            // DX10 header: first DWORD at offset 128 is dxgiFormat
                            const dxgiFormat = dds.getUint32(offset, true);
                            console.log(`[DDS/DX10] dxgiFormat = ${dxgiFormat}`);
                            offset += 20; // skip DDS_HEADER_DXT10 (20 bytes)
                            // map a few common DXGI formats to S3TC names (guessing typical ones)
                            switch (dxgiFormat) {
                                case 71: // DXGI_FORMAT_BC1_UNORM
                                    formatKey = 'DX10_BC1';
                                    blockSize = 8;
                                    break;
                                case 74: // DXGI_FORMAT_BC2_UNORM
                                    formatKey = 'DX10_BC2';
                                    blockSize = 16;
                                    break;
                                case 77: // DXGI_FORMAT_BC3_UNORM
                                    formatKey = 'DX10_BC3';
                                    blockSize = 16;
                                    break;
                                default:
                                    throw new Error('Unsupported DX10 DDS format: ' + dxgiFormat);
                            }
                        } else {
                            // legacy FourCC
                            switch (fourCC) {
                                case 0x31545844: // 'DXT1'
                                    formatKey = 'DXT1';
                                    blockSize = 8;
                                    break;
                                case 0x33545844: // 'DXT3'
                                    formatKey = 'DXT3';
                                    blockSize = 16;
                                    break;
                                case 0x35545844: // 'DXT5'
                                    formatKey = 'DXT5';
                                    blockSize = 16;
                                    break;
                                case 0x00000000:
                                    // no fourCC -> might be uncompressed
                                    uncompressed = true;
                                    // ddpfPixelFormat.dwRGBBitCount at offset 88
                                    bytesPerPixel = (dds.getUint32(88, true) || 32) / 8;
                                    console.log(`[DDS] Detected uncompressed format, bytesPerPixel=${bytesPerPixel}`);
                                    break;
                                default:
                                    throw new Error('Unsupported DDS legacy format: ' + fourCCToString(fourCC));
                            }
                        }

                        gl.bindTexture(gl.TEXTURE_2D, texture);

                        if (uncompressed) {
                            console.log("[DDS] Uploading uncompressed texture (single level).");
                            const expectedSize = width * height * bytesPerPixel;
                            const pixelData = new Uint8Array(source, offset, expectedSize);
                            const fmt = (bytesPerPixel === 4) ? gl.RGBA : gl.RGB;
                            gl.texImage2D(gl.TEXTURE_2D, 0, fmt, width, height, 0, fmt, gl.UNSIGNED_BYTE, pixelData);
                            applyTextureParams();
                            logGLError("texImage2D-uncompressed");
                        } else {
                            // compressed path: need S3TC ext
                            const ext =
                                gl.getExtension('WEBGL_compressed_texture_s3tc') ||
                                gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                                gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');

                            console.log("[DDS] S3TC extension:", !!ext);

                            if (!ext) throw new Error('S3TC compressed textures not supported on this device');

                            // map our formatKey -> ext constant (with safe fallbacks)
                            const formatMap = {
                                'DXT1': ext.COMPRESSED_RGB_S3TC_DXT1_EXT || ext.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                                'DXT3': ext.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                                'DXT5': ext.COMPRESSED_RGBA_S3TC_DXT5_EXT,
                                'DX10_BC1': ext.COMPRESSED_RGB_S3TC_DXT1_EXT || ext.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                                'DX10_BC2': ext.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                                'DX10_BC3': ext.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            };

                            const glFormat = formatMap[formatKey];
                            if (!glFormat) throw new Error('Unsupported/unknown compressed format key: ' + formatKey);

                            // upload each mip level if present
                            let widthLevel = width;
                            let heightLevel = height;
                            let currentOffset = offset;
                            console.log(`[DDS] Uploading compressed texture. baseOffset=${offset}, baseSize ~ ${Math.floor((Math.max(1, ((width + 3) >> 2)) * Math.max(1, ((height + 3) >> 2)) * blockSize))} bytes`);

                            for (let level = 0; level < mipMapCount; level++) {
                                const w = Math.max(1, widthLevel);
                                const h = Math.max(1, heightLevel);
                                const blocksAcross = Math.max(1, Math.floor((w + 3) / 4));
                                const blocksDown = Math.max(1, Math.floor((h + 3) / 4));
                                const size = blocksAcross * blocksDown * blockSize;

                                console.log(`[DDS][mip ${level}] w=${w}, h=${h}, blocks=${blocksAcross}x${blocksDown}, bytes=${size}, offset=${currentOffset}`);
                                // BOUNDS CHECK: make sure we won't read past the buffer
                                if (currentOffset + size > source.byteLength) {
                                    console.warn(`[DDS] Truncated file: expected ${size} bytes at offset ${currentOffset}, but file is ${source.byteLength}. Stopping at level ${level}.`);
                                    break; // stop uploading further levels (we must still ensure texture completeness below)
                                }

                                const byteArray = new Uint8Array(source, currentOffset, size);
                                gl.compressedTexImage2D(gl.TEXTURE_2D, level, glFormat, w, h, 0, byteArray);

                                if (logGLError(`compressedTexImage2D-level${level}`)) {
                                    console.error("[DDS] WebGL error when uploading compressed level", level);
                                }

                                currentOffset += size;
                                widthLevel = Math.floor(widthLevel / 2);
                                heightLevel = Math.floor(heightLevel / 2);

                                // stop if width/height already 1 and no extra data
                                if (widthLevel <= 0 && heightLevel <= 0) break;
                            }

                            // if we uploaded only level 0 but mipMapCount == 1, ensure filters are non-mipmap; if more than 1, enable mipmap filters
                            if (mipMapCount > 1) {
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                            } else {
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                            }
                        }

                        // tidy up
                        gl.bindTexture(gl.TEXTURE_2D, null);
                        console.log("=== loadTexture SUCCESS (DDS) ===");
                        return texture;
                    } catch (e) {
                        console.error("[loadTexture] Failed to load ArrayBuffer as DDS/uncompressed:", e);
                        // fallback white
                        const white = new Uint8Array([255, 255, 255, 255]);
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, white);
                        applyTextureParams();
                        gl.bindTexture(gl.TEXTURE_2D, null);
                        return texture;
                    }
                }

                // unknown source -> fallback
                console.warn('loadTexture: unknown source type, returning fallback');
                const fallback = this.createFallbackTexture(gl);
                return fallback;
            };



            async renderXACModelWorld(xacDataWorld) {
                const previewContent = document.getElementById('previewContent');

                // If a previous instance created resources, clean them up first
                if (previewContent._xacCleanup) {
                    try { previewContent._xacCleanup(); } catch (e) { console.warn('cleanup failed', e); }
                    previewContent._xacCleanup = null;
                }

                previewContent.classList.add("preview-xac");

                // Insert canvas in a stat-card container with scoped inline styles
                previewContent.innerHTML = `
        <div class="stat-card" 
             style="display:flex; justify-content:center; align-items:center; width:100%; height:70vh;">
            <canvas id="glCanvas" class="rounded shadow" 
                    style="background:#111; display:block; width:100%; height:100%;">
            </canvas>
        </div>
    `;

                let canvas = document.getElementById('glCanvas');

                // Keep references for cleanup
                const cleanupItems = {
                    rafId: null,
                    listeners: [],
                    gl: null,
                    vbo: null,
                    ibo: null,
                    vs: null,
                    fs: null,
                    program: null,
                    textures: [],
                };


                // Resize helper â€” set drawing buffer size to match displayed size (with HiDPI support)
                function resizeCanvas() {
                    if (!canvas) return;
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvas.getBoundingClientRect();

                    const w = Math.max(1, Math.floor(rect.width * dpr));
                    const h = Math.max(1, Math.floor(rect.height * dpr));

                    if (canvas.width !== w || canvas.height !== h) {
                        canvas.width = w;
                        canvas.height = h;
                        if (cleanupItems.gl) cleanupItems.gl.viewport(0, 0, w, h);
                    }
                }

                // Attach a listener and remember it for cleanup
                function addListener(target, type, fn, opts) {
                    target.addEventListener(type, fn, opts);
                    cleanupItems.listeners.push({ target, type, fn, opts });
                }

                // --- GL context ---
                const gl = canvas.getContext('webgl', { preserveDrawingBuffer: false });
                if (!gl) {
                    console.error('WebGL not supported');
                    return;
                }

                cleanupItems.gl = gl;

                // Initial resize (defer to next frame so layout has settled)
                requestAnimationFrame(resizeCanvas);

                // Watch window resizes
                addListener(window, 'resize', resizeCanvas);
                // --- Extract mesh data ---
                const positions = [], normals = [], indices = [], uvs = [], submeshInfos = [];

                const extractNode = async (node, depth = 0) => {
                    if (!node) return;

                    const indent = "  ".repeat(depth);

                    console.log(`${indent}Processing node:`, node.name ?? "(unnamed)");

                    if (node.model && node.model.submeshes) {
                        console.log(`${indent}  Submeshes: ${node.model.submeshes.length}`);

                        for (const sub of node.model.submeshes) {

                            // Skip submesh if unnamed or no texture
                            if ((!sub.name || sub.name.trim() === "" || sub.name.toLowerCase().includes("none")) &&
                                (!sub.textures || sub.textures.trim() === "" || sub.textures.toLowerCase().includes("none"))) {

                                console.warn(`${indent}  âš  Skipping submesh (no name or texture):`, sub.name);
                                continue;
                            }

                            console.log(`${indent}  â–¶ Submesh: ${sub.name}`);
                            console.log(`${indent}     Texture: ${sub.textures || "(none)"}`);

                            // Load texture
                            let tex = null;

                            if (sub.textures) {
                                // --- Replace .tga / .TGA â†’ .dds ---
                                let texPath = sub.textures.replace(/\.tga$/i, ".dds");

                                try {
                                    tex = await this.loadTextureFromServer(gl, texPath, 0);

                                    if (!tex) {
                                        console.warn(`${indent}     âš  Texture failed, using fallback white (${texPath})`);
                                    } else {
                                        console.log(`${indent}     âœ” Texture loaded (${texPath})`);
                                    }
                                } catch (e) {
                                    console.error(`${indent}     âŒ Texture load error (${texPath}):`, e);
                                }
                            }

                            const baseIndex = positions.length / 3;

                            // Positions / Normals / UVs
                            if (sub.positions && sub.positions.length > 0) {
                                console.log(`${indent}     Vertices: ${sub.positions.length}`);

                                for (let i = 0; i < sub.positions.length; i++) {
                                    const pos = sub.positions[i];
                                    positions.push(pos.x, pos.y, pos.z);

                                    if (sub.normals && sub.normals[i]) {
                                        const n = sub.normals[i];
                                        normals.push(n.x, n.y, n.z);
                                    } else {
                                        normals.push(0, 0, 1);
                                    }

                                    if (sub.uvcoords && sub.uvcoords[i]) {
                                        uvs.push(sub.uvcoords[i].x ?? 0, 1.0 - (sub.uvcoords[i].y ?? 0));
                                    } else {
                                        uvs.push(0, 0);
                                    }
                                }
                            } else {
                                console.warn(`${indent}     âš  No position data, skipping`);
                            }

                            // Indices
                            if (sub.indices && sub.indices.length > 0) {
                                console.log(`${indent}     Indices: ${sub.indices.length}`);
                                for (const idx of sub.indices) indices.push(baseIndex + idx);
                            } else {
                                const vertCount = sub.positions ? sub.positions.length : 4;
                                console.warn(`${indent}     âš  No index data, auto-generating ${vertCount} sequential indices`);
                                for (let i = 0; i < vertCount; i++) indices.push(baseIndex + i);
                            }

                            const indexCount = sub.indices ? sub.indices.length : (sub.positions?.length ?? 0);
                            const indexOffset = indices.length - indexCount;

                            console.log(`${indent}     â†’ indexOffset=${indexOffset}, indexCount=${indexCount}`);

                            submeshInfos.push({
                                texture: tex,
                                indexOffset,
                                indexCount
                            });

                            // Fallback texture
                            if (!tex) {
                                tex = this.createFallbackTexture(gl);
                            } else if (tex !== gl._fallbackWhiteTexture) {
                                cleanupItems.textures.push(tex);
                            }
                        }
                    }

                    if (node.children) {
                        for (const child of node.children) {
                            await extractNode(child, depth + 1);
                        }
                    }
                };

                // Start extracting
                if (xacDataWorld.root_nodes && xacDataWorld.root_nodes.length > 0) {
                    console.log("=== Begin XAC Mesh Extraction ===");
                    for (const root of xacDataWorld.root_nodes) await extractNode(root);
                    console.log("=== Mesh Extraction Complete ===");
                } else {
                    console.warn("âš  No root_nodes found. Using fallback quad.");
                    positions.push(-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1);
                    normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1);
                    uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                    indices.push(0, 1, 2, 2, 3, 0);
                }

                // --- Bounding box & view setup ---
                console.log("=== Compute Bounding Box ===");

                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i], y = positions[i + 1], z = positions[i + 2];
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    minZ = Math.min(minZ, z);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                    maxZ = Math.max(maxZ, z);
                }

                console.log("Bounding Box:");
                console.log("  min:", minX, minY, minZ);
                console.log("  max:", maxX, maxY, maxZ);

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;

                const sizeX = maxX - minX;
                const sizeY = maxY - minY;
                const sizeZ = maxZ - minZ;

                const maxSize = Math.max(sizeX, sizeY, sizeZ) || 1;
                let distance = maxSize * 1.5;

                console.log(`  maxSize=${maxSize}, cameraDistance=${distance}`);


                // --- Interleave vertex data ---
                const vertexCount = positions.length / 3;
                console.log("=== Interleave Vertex Data ===");
                console.log(`Vertex Count: ${vertexCount}`);

                if (uvs.length / 2 !== vertexCount) {
                    console.warn(
                        `âš  UV count mismatch! UVs=${uvs.length / 2}, Vertices=${vertexCount}. `
                        + `Missing UVs may cause gray texture.`
                    );
                    console.log("Sample UVs:", uvs.slice(0, 10));
                }

                const vertexData = new Float32Array(vertexCount * 8);

                for (let i = 0; i < vertexCount; i++) {
                    vertexData[i * 8 + 0] = positions[i * 3 + 0];
                    vertexData[i * 8 + 1] = positions[i * 3 + 1];
                    vertexData[i * 8 + 2] = positions[i * 3 + 2];

                    vertexData[i * 8 + 3] = normals[i * 3 + 0];
                    vertexData[i * 8 + 4] = normals[i * 3 + 1];
                    vertexData[i * 8 + 5] = normals[i * 3 + 2];

                    const u = uvs[i * 2 + 0] ?? 0;
                    const v = uvs[i * 2 + 1] ?? 0;

                    vertexData[i * 8 + 6] = u;
                    vertexData[i * 8 + 7] = v;
                }

                console.log("Interleaved vertexData created. Total floats:", vertexData.length);


                // --- Index Array Setup ---
                console.log("=== Index Buffer Setup ===");
                console.log(`Index Count: ${indices.length}`);

                const needUint32 = (vertexCount > 65535);
                const idxExt = gl.getExtension('OES_element_index_uint');

                let indexArray;
                let indexType;

                if (needUint32) {
                    if (idxExt) {
                        console.log("Using Uint32 indices (extension available).");
                        indexArray = new Uint32Array(indices);
                        indexType = gl.UNSIGNED_INT;
                    } else {
                        console.warn(
                            "âš  Mesh requires >65535 vertices but OES_element_index_uint is missing.\n" +
                            "Truncating indices to 65535 â€” geometry may be broken!"
                        );

                        indices = indices.slice(0, 65535);
                        indexArray = new Uint16Array(indices);
                        indexType = gl.UNSIGNED_SHORT;
                    }
                } else {
                    console.log("Using Uint16 indices (fits).");
                    indexArray = new Uint16Array(indices);
                    indexType = gl.UNSIGNED_SHORT;
                }

                console.log(`IndexType = ${indexType === gl.UNSIGNED_INT ? "UNSIGNED_INT" : "UNSIGNED_SHORT"}`);
                console.log("IndexArray length:", indexArray.length);


                // --- Shaders (same sources) ---
                const vsSource = `
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;
varying vec3 vNormal;

uniform mat4 uMVP;

void main() {
    gl_Position = uMVP * vec4(aPosition,1.0);
    vTexCoord = aTexCoord;
    vNormal = aNormal;
}
`;

                const fsSource = `
                precision mediump float;
                varying vec2 vTexCoord;
                varying vec3 vNormal;
                uniform sampler2D uTexture;

                void main() {
                    vec3 texColor = texture2D(uTexture, vTexCoord).rgb;

                    vec3 normal = normalize(vNormal);

                    // Six directional lights (+X, -X, +Y, -Y, +Z, -Z)
                    vec3 lightDirs[6];
                    lightDirs[0] = vec3( 1.0,  0.0,  0.0);
                    lightDirs[1] = vec3(-1.0,  0.0,  0.0);
                    lightDirs[2] = vec3( 0.0,  1.0,  0.0);
                    lightDirs[3] = vec3( 0.0, -1.0,  0.0);
                    lightDirs[4] = vec3( 0.0,  0.0,  1.0);
                    lightDirs[5] = vec3( 0.0,  0.0, -1.0);

                    float diff = 0.0;
                    for (int i = 0; i < 6; i++) {
                        diff += max(dot(normal, lightDirs[i]), 0.0);
                    }
                    diff /= 4.0; // average contribution

                    vec3 ambient = texColor * 0.2; // ambient term
                    vec3 color = texColor * diff + ambient;

                    gl_FragColor = vec4(color, 1.0);
                }

                `;


                function compileShader(src, type) {
                    const s = gl.createShader(type);
                    gl.shaderSource(s, src);
                    gl.compileShader(s);
                    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                        const log = gl.getShaderInfoLog(s);
                        console.error('Shader compile error:', log);
                    }
                    return s;
                }

                // Create program and buffers
                const vs = compileShader(vsSource, gl.VERTEX_SHADER);
                const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
                const program = gl.createProgram();
                if (vs) gl.attachShader(program, vs);
                if (fs) gl.attachShader(program, fs);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program link error:', gl.getProgramInfoLog(program));
                }
                gl.useProgram(program);

                const vbo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

                const ibo = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);

                // Attribute setup
                const aPos = gl.getAttribLocation(program, 'aPosition');
                const aNormal = gl.getAttribLocation(program, 'aNormal');
                const aTex = gl.getAttribLocation(program, 'aTexCoord');
                gl.enableVertexAttribArray(aPos);
                gl.enableVertexAttribArray(aNormal);
                gl.enableVertexAttribArray(aTex);

                const stride = 8 * 4; // 8 floats: pos+normal+uv
                gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, stride, 0);
                gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, stride, 12);
                gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, stride, 24);

                if (aPos < 0) console.warn('aPosition attribute not found');
                if (aNormal < 0) console.warn('aNormal attribute not found');
                if (aTex < 0) console.warn('aTexCoord attribute not found');

                // UV sanity
                console.log('UV count:', uvs.length / 2);


                const uTexture = gl.getUniformLocation(program, 'uTexture');
                const uMVP = gl.getUniformLocation(program, 'uMVP');

                // helper matrices (unchanged)
                function identity() { return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]); }
                function perspective(fov, aspect, near, far) {
                    const f = 1 / Math.tan(fov / 2), nf = 1 / (near - far);
                    return new Float32Array([
                        f / aspect, 0, 0, 0,
                        0, f, 0, 0,
                        0, 0, (far + near) * nf, -1,
                        0, 0, (2 * far * near) * nf, 0
                    ]);
                }
                function multiply(a, b) {
                    const o = new Float32Array(16);
                    for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++)
                        o[j * 4 + i] = a[i] * b[j * 4] + a[i + 4] * b[j * 4 + 1] + a[i + 8] * b[j * 4 + 2] + a[i + 12] * b[j * 4 + 3];
                    return o;
                }
                function translate(m, x, y, z) { const t = identity(); t[12] = -x; t[13] = -y; t[14] = -z - distance; return multiply(m, t); }
                function rotateX(m, a) { const c = Math.cos(a), s = Math.sin(a); const r = identity(); r[5] = c; r[6] = s; r[9] = -s; r[10] = c; return multiply(m, r); }
                function rotateY(m, a) { const c = Math.cos(a), s = Math.sin(a); const r = identity(); r[0] = c; r[2] = s; r[8] = -s; r[10] = c; return multiply(m, r); }

                let rotX = 0, rotY = 0;
                let mouseDown = false, lastX = 0, lastY = 0;

                // Single set of pointer handlers (no duplicates)
                addListener(canvas, 'mousedown', e => { mouseDown = true; lastX = e.clientX; lastY = e.clientY; });
                addListener(window, 'mouseup', () => { mouseDown = false; });
                addListener(canvas, 'mousemove', e => {
                    if (mouseDown) {
                        rotY -= (e.clientX - lastX) * 0.01;
                        // Update rotX with clamping (same clamp as earlier)
                        rotX += (e.clientY - lastY) * 0.01;
                        const maxRot = Math.PI / 2 - 0.01;
                        if (rotX > maxRot) rotX = maxRot;
                        if (rotX < -maxRot) rotX = -maxRot;

                        lastX = e.clientX;
                        lastY = e.clientY;
                    }
                });

                addListener(canvas, 'wheel', e => {
                    e.preventDefault();
                    const zoomSpeed = 1.02;
                    if (e.deltaY < 0) {
                        distance /= zoomSpeed;
                    } else {
                        distance *= zoomSpeed;
                    }
                    distance = Math.max(maxSize * 0.5, Math.min(maxSize * 10, distance));
                }, { passive: false });

                // store GL resources for cleanup
                cleanupItems.vbo = vbo;
                cleanupItems.ibo = ibo;
                cleanupItems.vs = vs;
                cleanupItems.fs = fs;
                cleanupItems.program = program;

                // Helper for index byte size (define once)
                function bytesPerIndex(type) {
                    return (type === gl.UNSIGNED_INT) ? 4 : 2;
                }

                // Ensure program is active and sampler set once
                gl.useProgram(program);
                if (uTexture !== -1 && uTexture !== null) {
                    gl.uniform1i(uTexture, 0); // sampler uses texture unit 0
                } else {
                    console.warn('uTexture uniform location appears invalid:', uTexture);
                }

                function renderLoop() {
                    resizeCanvas();
                    gl.clearColor(0.1, 0.1, 0.1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.enable(gl.DEPTH_TEST);

                    const proj = perspective(Math.PI / 4, canvas.width / canvas.height, 0.01, 30000);
                    let view = translate(identity(), centerX, centerY, centerZ);
                    view = rotateX(view, rotX);
                    view = rotateY(view, rotY);
                    const mvp = multiply(proj, view);

                    // upload MVP once
                    gl.uniformMatrix4fv(uMVP, false, mvp);

                    // bind element array once
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);

                    // precompute index byte size for chosen indexType
                    const indexByteSize = bytesPerIndex(indexType);

                    for (const sub of submeshInfos) {
                        if (!sub || sub.indexCount <= 0) continue;

                        // bind texture (or fallback) to texture unit 0
                        const texToBind = sub.texture || gl._fallbackWhiteTexture;
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, texToBind);
                        // sampler already set to unit 0 above; if you prefer to be explicit per-submesh you can uncomment:
                        // gl.uniform1i(uTexture, 0);

                        // compute byte offset for drawElements (must be in BYTES)
                        const offsetBytes = sub.indexOffset * indexByteSize;

                        // Optional diagnostic (uncomment to debug)
                        // console.log('Drawing submesh', { indexCount: sub.indexCount, indexOffset: sub.indexOffset, offsetBytes });

                        // draw
                        gl.drawElements(gl.TRIANGLES, sub.indexCount, indexType, offsetBytes);
                    }

                    cleanupItems.rafId = requestAnimationFrame(renderLoop);
                }

                renderLoop();

                // Provide a cleanup function so future calls can dispose of resources
                previewContent._xacCleanup = () => {
                    // Cancel RAF
                    if (cleanupItems.rafId != null) {
                        try { cancelAnimationFrame(cleanupItems.rafId); } catch (e) { }
                        cleanupItems.rafId = null;
                    }
                    // Remove listeners
                    for (const L of cleanupItems.listeners) {
                        try { L.target.removeEventListener(L.type, L.fn, L.opts); } catch (e) { }
                    }
                    cleanupItems.listeners.length = 0;

                    // Delete GL resources (if context still available)
                    try {
                        const g = cleanupItems.gl;
                        if (g) {
                            gl.bindTexture(gl.TEXTURE_2D, null);
                            for (const t of cleanupItems.textures) {
                                try { g.deleteTexture(t); } catch (e) { }
                            }
                            cleanupItems.textures = [];
                            if (cleanupItems.vbo) { g.deleteBuffer(cleanupItems.vbo); cleanupItems.vbo = null; }
                            if (cleanupItems.ibo) { g.deleteBuffer(cleanupItems.ibo); cleanupItems.ibo = null; }
                            if (cleanupItems.program) {
                                try {
                                    if (cleanupItems.vs) { g.detachShader(cleanupItems.program, cleanupItems.vs); g.deleteShader(cleanupItems.vs); cleanupItems.vs = null; }
                                    if (cleanupItems.fs) { g.detachShader(cleanupItems.program, cleanupItems.fs); g.deleteShader(cleanupItems.fs); cleanupItems.fs = null; }
                                } catch (e) { /* some browsers throw when detaching */ }
                                try { g.deleteProgram(cleanupItems.program); } catch (e) { }
                                cleanupItems.program = null;
                            }
                        }
                    } catch (e) {
                        console.warn('GL cleanup error', e);
                    }

                    // Clear canvas and remove DOM nodes if desired (kept minimal)
                    // previewContent.innerHTML = ''; // if you want to fully remove canvas output
                };

                // (Optional) Also cleanup when the canvas context is lost
                function onContextLost(ev) {
                    ev.preventDefault();
                    if (previewContent._xacCleanup) previewContent._xacCleanup();
                }
                addListener(canvas, 'webglcontextlost', onContextLost);
            }



            async renderXACModel(xacData) {
                const previewContent = document.getElementById('previewContent');

                // If a previous instance created resources, clean them up first
                if (previewContent._xacCleanup) {
                    try { previewContent._xacCleanup(); } catch (e) { console.warn('cleanup failed', e); }
                    previewContent._xacCleanup = null;
                }

                previewContent.classList.add("preview-xac");

                // Insert canvas in a stat-card container with scoped inline styles
                previewContent.innerHTML = `
        <div class="stat-card" 
             style="display:flex; justify-content:center; align-items:center; width:100%; height:70vh;">
            <canvas id="glCanvas" class="rounded shadow" 
                    style="background:#111; display:block; width:100%; height:100%;">
            </canvas>
        </div>
    `;

                let canvas = document.getElementById('glCanvas');

                // Keep references for cleanup
                const cleanupItems = {
                    rafId: null,
                    listeners: [],
                    gl: null,
                    vbo: null,
                    ibo: null,
                    vs: null,
                    fs: null,
                    program: null,
                    textures: [],
                };


                // Resize helper â€” set drawing buffer size to match displayed size (with HiDPI support)
                function resizeCanvas() {
                    if (!canvas) return;
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvas.getBoundingClientRect();

                    const w = Math.max(1, Math.floor(rect.width * dpr));
                    const h = Math.max(1, Math.floor(rect.height * dpr));

                    if (canvas.width !== w || canvas.height !== h) {
                        canvas.width = w;
                        canvas.height = h;
                        if (cleanupItems.gl) cleanupItems.gl.viewport(0, 0, w, h);
                    }
                }

                // Attach a listener and remember it for cleanup
                function addListener(target, type, fn, opts) {
                    target.addEventListener(type, fn, opts);
                    cleanupItems.listeners.push({ target, type, fn, opts });
                }

                // --- GL context ---
                const gl = canvas.getContext('webgl', { preserveDrawingBuffer: false });
                if (!gl) {
                    console.error('WebGL not supported');
                    return;
                }

                cleanupItems.gl = gl;

                // Initial resize (defer to next frame so layout has settled)
                requestAnimationFrame(resizeCanvas);

                // Watch window resizes
                addListener(window, 'resize', resizeCanvas);
                // --- Extract mesh data ---
                const positions = [], normals = [], indices = [], uvs = [], submeshInfos = [];

                const extractNode = async (node, depth = 0) => {
                    if (!node) return;

                    const indent = "  ".repeat(depth);

                    console.log(`${indent}Processing node:`, node.name ?? "(unnamed)");

                    if (node.model && node.model.submeshes) {
                        console.log(`${indent}  Submeshes: ${node.model.submeshes.length}`);

                        for (const sub of node.model.submeshes) {

                            // Skip submesh if unnamed or no texture
                            if ((!sub.name || sub.name.trim() === "" || sub.name.toLowerCase().includes("none")) &&
                                (!sub.textures || sub.textures.trim() === "" || sub.textures.toLowerCase().includes("none"))) {

                                console.warn(`${indent}  âš  Skipping submesh (no name or texture):`, sub.name);
                                continue;
                            }

                            console.log(`${indent}  â–¶ Submesh: ${sub.name}`);
                            console.log(`${indent}     Texture: ${sub.textures || "(none)"}`);

                            // Load texture
                            let tex = null;

                            if (sub.textures) {
                                // --- Replace .tga / .TGA â†’ .dds ---
                                let texPath = sub.textures.replace(/\.tga$/i, ".dds");

                                try {
                                    tex = await this.loadTextureFromServer(gl, texPath, 0);

                                    if (!tex) {
                                        console.warn(`${indent}     âš  Texture failed, using fallback white (${texPath})`);
                                    } else {
                                        console.log(`${indent}     âœ” Texture loaded (${texPath})`);
                                    }
                                } catch (e) {
                                    console.error(`${indent}     âŒ Texture load error (${texPath}):`, e);
                                }
                            }

                            const baseIndex = positions.length / 3;

                            // Positions / Normals / UVs
                            if (sub.positions && sub.positions.length > 0) {
                                console.log(`${indent}     Vertices: ${sub.positions.length}`);

                                for (let i = 0; i < sub.positions.length; i++) {
                                    const pos = sub.positions[i];
                                    positions.push(pos.x, pos.y, pos.z);

                                    if (sub.normals && sub.normals[i]) {
                                        const n = sub.normals[i];
                                        normals.push(n.x, n.y, n.z);
                                    } else {
                                        normals.push(0, 0, 1);
                                    }

                                    if (sub.uvcoords && sub.uvcoords[i]) {
                                        uvs.push(sub.uvcoords[i].x ?? 0, 1.0 - (sub.uvcoords[i].y ?? 0));
                                    } else {
                                        uvs.push(0, 0);
                                    }
                                }
                            } else {
                                console.warn(`${indent}     âš  No position data, skipping`);
                            }

                            // Indices
                            if (sub.indices && sub.indices.length > 0) {
                                console.log(`${indent}     Indices: ${sub.indices.length}`);
                                for (const idx of sub.indices) indices.push(baseIndex + idx);
                            } else {
                                const vertCount = sub.positions ? sub.positions.length : 4;
                                console.warn(`${indent}     âš  No index data, auto-generating ${vertCount} sequential indices`);
                                for (let i = 0; i < vertCount; i++) indices.push(baseIndex + i);
                            }

                            const indexCount = sub.indices ? sub.indices.length : (sub.positions?.length ?? 0);
                            const indexOffset = indices.length - indexCount;

                            console.log(`${indent}     â†’ indexOffset=${indexOffset}, indexCount=${indexCount}`);

                            submeshInfos.push({
                                texture: tex,
                                indexOffset,
                                indexCount
                            });

                            // Fallback texture
                            if (!tex) {
                                tex = this.createFallbackTexture(gl);
                            } else if (tex !== gl._fallbackWhiteTexture) {
                                cleanupItems.textures.push(tex);
                            }
                        }
                    }

                    if (node.children) {
                        for (const child of node.children) {
                            await extractNode(child, depth + 1);
                        }
                    }
                };

                // Start extracting
                if (xacData.root_nodes && xacData.root_nodes.length > 0) {
                    console.log("=== Begin XAC Mesh Extraction ===");
                    for (const root of xacData.root_nodes) await extractNode(root);
                    console.log("=== Mesh Extraction Complete ===");
                } else {
                    console.warn("âš  No root_nodes found. Using fallback quad.");
                    positions.push(-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1);
                    normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1);
                    uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                    indices.push(0, 1, 2, 2, 3, 0);
                }

                // --- Bounding box & view setup ---
                console.log("=== Compute Bounding Box ===");

                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i], y = positions[i + 1], z = positions[i + 2];
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    minZ = Math.min(minZ, z);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                    maxZ = Math.max(maxZ, z);
                }

                console.log("Bounding Box:");
                console.log("  min:", minX, minY, minZ);
                console.log("  max:", maxX, maxY, maxZ);

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;

                const sizeX = maxX - minX;
                const sizeY = maxY - minY;
                const sizeZ = maxZ - minZ;

                const maxSize = Math.max(sizeX, sizeY, sizeZ) || 1;
                let distance = maxSize * 1.5;

                console.log(`  maxSize=${maxSize}, cameraDistance=${distance}`);


                // --- Interleave vertex data ---
                const vertexCount = positions.length / 3;
                console.log("=== Interleave Vertex Data ===");
                console.log(`Vertex Count: ${vertexCount}`);

                if (uvs.length / 2 !== vertexCount) {
                    console.warn(
                        `âš  UV count mismatch! UVs=${uvs.length / 2}, Vertices=${vertexCount}. `
                        + `Missing UVs may cause gray texture.`
                    );
                    console.log("Sample UVs:", uvs.slice(0, 10));
                }

                const vertexData = new Float32Array(vertexCount * 8);

                for (let i = 0; i < vertexCount; i++) {
                    vertexData[i * 8 + 0] = positions[i * 3 + 0];
                    vertexData[i * 8 + 1] = positions[i * 3 + 1];
                    vertexData[i * 8 + 2] = positions[i * 3 + 2];

                    vertexData[i * 8 + 3] = normals[i * 3 + 0];
                    vertexData[i * 8 + 4] = normals[i * 3 + 1];
                    vertexData[i * 8 + 5] = normals[i * 3 + 2];

                    const u = uvs[i * 2 + 0] ?? 0;
                    const v = uvs[i * 2 + 1] ?? 0;

                    vertexData[i * 8 + 6] = u;
                    vertexData[i * 8 + 7] = v;
                }

                console.log("Interleaved vertexData created. Total floats:", vertexData.length);


                // --- Index Array Setup ---
                console.log("=== Index Buffer Setup ===");
                console.log(`Index Count: ${indices.length}`);

                const needUint32 = (vertexCount > 65535);
                const idxExt = gl.getExtension('OES_element_index_uint');

                let indexArray;
                let indexType;

                if (needUint32) {
                    if (idxExt) {
                        console.log("Using Uint32 indices (extension available).");
                        indexArray = new Uint32Array(indices);
                        indexType = gl.UNSIGNED_INT;
                    } else {
                        console.warn(
                            "âš  Mesh requires >65535 vertices but OES_element_index_uint is missing.\n" +
                            "Truncating indices to 65535 â€” geometry may be broken!"
                        );

                        indices = indices.slice(0, 65535);
                        indexArray = new Uint16Array(indices);
                        indexType = gl.UNSIGNED_SHORT;
                    }
                } else {
                    console.log("Using Uint16 indices (fits).");
                    indexArray = new Uint16Array(indices);
                    indexType = gl.UNSIGNED_SHORT;
                }

                console.log(`IndexType = ${indexType === gl.UNSIGNED_INT ? "UNSIGNED_INT" : "UNSIGNED_SHORT"}`);
                console.log("IndexArray length:", indexArray.length);


                // --- Shaders (same sources) ---
                const vsSource = `
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;
varying vec3 vNormal;

uniform mat4 uMVP;

void main() {
    gl_Position = uMVP * vec4(aPosition,1.0);
    vTexCoord = aTexCoord;
    vNormal = aNormal;
}
`;

                const fsSource = `
precision mediump float;
varying vec2 vTexCoord;
varying vec3 vNormal;
uniform sampler2D uTexture;

void main() {
    vec4 texColor = texture2D(uTexture, vTexCoord); // sample RGBA

    vec3 normal = normalize(vNormal);

    // Six directional lights (+X, -X, +Y, -Y, +Z, -Z)
    vec3 lightDirs[6];
    lightDirs[0] = vec3( 1.0,  0.0,  0.0);
    lightDirs[1] = vec3(-1.0,  0.0,  0.0);
    lightDirs[2] = vec3( 0.0,  1.0,  0.0);
    lightDirs[3] = vec3( 0.0, -1.0,  0.0);
    lightDirs[4] = vec3( 0.0,  0.0,  1.0);
    lightDirs[5] = vec3( 0.0,  0.0, -1.0);

    float diff = 0.0;
    for (int i = 0; i < 6; i++) {
        diff += max(dot(normal, lightDirs[i]), 0.0);
    }
    diff /= 4.0; // average contribution

    vec3 ambient = texColor.rgb * 0.2; // ambient term
    vec3 color = texColor.rgb * diff + ambient;

    // output with alpha from texture
    gl_FragColor = vec4(color, texColor.a);

    // optional: discard fully transparent pixels
    // if (texColor.a < 0.1) discard;
}


                `;


                function compileShader(src, type) {
                    const s = gl.createShader(type);
                    gl.shaderSource(s, src);
                    gl.compileShader(s);
                    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                        const log = gl.getShaderInfoLog(s);
                        console.error('Shader compile error:', log);
                    }
                    return s;
                }

                // Create program and buffers
                const vs = compileShader(vsSource, gl.VERTEX_SHADER);
                const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
                const program = gl.createProgram();
                if (vs) gl.attachShader(program, vs);
                if (fs) gl.attachShader(program, fs);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program link error:', gl.getProgramInfoLog(program));
                }
                gl.useProgram(program);

                const vbo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

                const ibo = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);

                // Attribute setup
                const aPos = gl.getAttribLocation(program, 'aPosition');
                const aNormal = gl.getAttribLocation(program, 'aNormal');
                const aTex = gl.getAttribLocation(program, 'aTexCoord');
                gl.enableVertexAttribArray(aPos);
                gl.enableVertexAttribArray(aNormal);
                gl.enableVertexAttribArray(aTex);

                const stride = 8 * 4; // 8 floats: pos+normal+uv
                gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, stride, 0);
                gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, stride, 12);
                gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, stride, 24);

                if (aPos < 0) console.warn('aPosition attribute not found');
                if (aNormal < 0) console.warn('aNormal attribute not found');
                if (aTex < 0) console.warn('aTexCoord attribute not found');

                // UV sanity
                console.log('UV count:', uvs.length / 2);


                const uTexture = gl.getUniformLocation(program, 'uTexture');
                const uMVP = gl.getUniformLocation(program, 'uMVP');

                // helper matrices (unchanged)
                function identity() { return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]); }
                function perspective(fov, aspect, near, far) {
                    const f = 1 / Math.tan(fov / 2), nf = 1 / (near - far);
                    return new Float32Array([
                        f / aspect, 0, 0, 0,
                        0, f, 0, 0,
                        0, 0, (far + near) * nf, -1,
                        0, 0, (2 * far * near) * nf, 0
                    ]);
                }
                function multiply(a, b) {
                    const o = new Float32Array(16);
                    for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++)
                        o[j * 4 + i] = a[i] * b[j * 4] + a[i + 4] * b[j * 4 + 1] + a[i + 8] * b[j * 4 + 2] + a[i + 12] * b[j * 4 + 3];
                    return o;
                }
                function translate(m, x, y, z) { const t = identity(); t[12] = -x; t[13] = -y; t[14] = -z - distance; return multiply(m, t); }
                function rotateX(m, a) { const c = Math.cos(a), s = Math.sin(a); const r = identity(); r[5] = c; r[6] = s; r[9] = -s; r[10] = c; return multiply(m, r); }
                function rotateY(m, a) { const c = Math.cos(a), s = Math.sin(a); const r = identity(); r[0] = c; r[2] = s; r[8] = -s; r[10] = c; return multiply(m, r); }

                let rotX = 0, rotY = 0;
                let mouseDown = false, lastX = 0, lastY = 0;

                // Single set of pointer handlers (no duplicates)
                addListener(canvas, 'mousedown', e => { mouseDown = true; lastX = e.clientX; lastY = e.clientY; });
                addListener(window, 'mouseup', () => { mouseDown = false; });
                addListener(canvas, 'mousemove', e => {
                    if (mouseDown) {
                        rotY -= (e.clientX - lastX) * 0.01;
                        // Update rotX with clamping (same clamp as earlier)
                        rotX += (e.clientY - lastY) * 0.01;
                        const maxRot = Math.PI / 2 - 0.01;
                        if (rotX > maxRot) rotX = maxRot;
                        if (rotX < -maxRot) rotX = -maxRot;

                        lastX = e.clientX;
                        lastY = e.clientY;
                    }
                });

                addListener(canvas, 'wheel', e => {
                    e.preventDefault();
                    const zoomSpeed = 1.02;
                    if (e.deltaY < 0) {
                        distance /= zoomSpeed;
                    } else {
                        distance *= zoomSpeed;
                    }
                    distance = Math.max(maxSize * 0.5, Math.min(maxSize * 10, distance));
                }, { passive: false });

                // store GL resources for cleanup
                cleanupItems.vbo = vbo;
                cleanupItems.ibo = ibo;
                cleanupItems.vs = vs;
                cleanupItems.fs = fs;
                cleanupItems.program = program;

                // Helper for index byte size (define once)
                function bytesPerIndex(type) {
                    return (type === gl.UNSIGNED_INT) ? 4 : 2;
                }

                // Ensure program is active and sampler set once
                gl.useProgram(program);
                if (uTexture !== -1 && uTexture !== null) {
                    gl.uniform1i(uTexture, 0); // sampler uses texture unit 0
                } else {
                    console.warn('uTexture uniform location appears invalid:', uTexture);
                }

                function renderLoop() {
                    resizeCanvas();
                    gl.clearColor(0.1, 0.1, 0.1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.enable(gl.DEPTH_TEST);

                    const proj = perspective(Math.PI / 4, canvas.width / canvas.height, 0.01, 30000);
                    let view = translate(identity(), centerX, centerY, centerZ);
                    view = rotateX(view, rotX);
                    view = rotateY(view, rotY);
                    const mvp = multiply(proj, view);

                    // upload MVP once
                    gl.uniformMatrix4fv(uMVP, false, mvp);

                    // bind element array once
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);

                    // precompute index byte size for chosen indexType
                    const indexByteSize = bytesPerIndex(indexType);

                    for (const sub of submeshInfos) {
                        if (!sub || sub.indexCount <= 0) continue;

                        // bind texture (or fallback) to texture unit 0
                        const texToBind = sub.texture || gl._fallbackWhiteTexture;
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, texToBind);
                        // sampler already set to unit 0 above; if you prefer to be explicit per-submesh you can uncomment:
                        // gl.uniform1i(uTexture, 0);

                        // compute byte offset for drawElements (must be in BYTES)
                        const offsetBytes = sub.indexOffset * indexByteSize;

                        // Optional diagnostic (uncomment to debug)
                        // console.log('Drawing submesh', { indexCount: sub.indexCount, indexOffset: sub.indexOffset, offsetBytes });

                        // draw
                        gl.drawElements(gl.TRIANGLES, sub.indexCount, indexType, offsetBytes);
                    }

                    cleanupItems.rafId = requestAnimationFrame(renderLoop);
                }

                renderLoop();

                // Provide a cleanup function so future calls can dispose of resources
                previewContent._xacCleanup = () => {
                    // Cancel RAF
                    if (cleanupItems.rafId != null) {
                        try { cancelAnimationFrame(cleanupItems.rafId); } catch (e) { }
                        cleanupItems.rafId = null;
                    }
                    // Remove listeners
                    for (const L of cleanupItems.listeners) {
                        try { L.target.removeEventListener(L.type, L.fn, L.opts); } catch (e) { }
                    }
                    cleanupItems.listeners.length = 0;

                    // Delete GL resources (if context still available)
                    try {
                        const g = cleanupItems.gl;
                        if (g) {
                            gl.bindTexture(gl.TEXTURE_2D, null);
                            for (const t of cleanupItems.textures) {
                                try { g.deleteTexture(t); } catch (e) { }
                            }
                            cleanupItems.textures = [];
                            if (cleanupItems.vbo) { g.deleteBuffer(cleanupItems.vbo); cleanupItems.vbo = null; }
                            if (cleanupItems.ibo) { g.deleteBuffer(cleanupItems.ibo); cleanupItems.ibo = null; }
                            if (cleanupItems.program) {
                                try {
                                    if (cleanupItems.vs) { g.detachShader(cleanupItems.program, cleanupItems.vs); g.deleteShader(cleanupItems.vs); cleanupItems.vs = null; }
                                    if (cleanupItems.fs) { g.detachShader(cleanupItems.program, cleanupItems.fs); g.deleteShader(cleanupItems.fs); cleanupItems.fs = null; }
                                } catch (e) { /* some browsers throw when detaching */ }
                                try { g.deleteProgram(cleanupItems.program); } catch (e) { }
                                cleanupItems.program = null;
                            }
                        }
                    } catch (e) {
                        console.warn('GL cleanup error', e);
                    }

                    // Clear canvas and remove DOM nodes if desired (kept minimal)
                    // previewContent.innerHTML = ''; // if you want to fully remove canvas output
                };

                // (Optional) Also cleanup when the canvas context is lost
                function onContextLost(ev) {
                    ev.preventDefault();
                    if (previewContent._xacCleanup) previewContent._xacCleanup();
                }
                addListener(canvas, 'webglcontextlost', onContextLost);
            }


            renderIESTable(iesData) {
                const previewContent = document.getElementById('previewContent');

                if (!iesData.data || iesData.data.length === 0) {
                    previewContent.innerHTML = '<div class="text-light text-center p-4">No data available</div>';
                    return;
                }

                // Sort columns first by decl_idx, then by type_data
                let sortedColumn = [...iesData.columns]
                    .sort((a, b) => a.decl_idx - b.decl_idx)
                    .sort((a, b) => a.type_data - b.type_data);

                // Build headers
                const headers = sortedColumn
                    .map(col => col.name || col.column)
                    .filter(name => name.trim());

                let tableHTML = `
    <div class="ies-table">
        <div class="mb-3">
            <h4 class="text-center text-light">IES Filename : ${iesData.header.idspace}</h4>
            <small class="text-muted">
                Version: ${iesData.header.version} | 
                Fields: ${iesData.header.num_field} | 
                Columns: ${iesData.header.num_column}
            </small>
        </div>
        <div class="table-responsive" style="overflow:auto;">
            <table class="table table-sm table-dark table-striped table-bordered align-middle text-center">
                <thead class="table-secondary text-dark sticky-top">
                    <tr>
                        <th scope="col" class="align-middle">Row Number</th>
                        <th scope="col" class="align-middle">Index Number</th>
                        <th scope="col" class="align-middle">Index</th>`;

                headers.forEach(header => {
                    tableHTML += `<th scope="col" class="align-middle">${header}</th>`;
                });

                tableHTML += `
                    </tr>
                </thead>
                <tbody>
    `;

                let numberRow = 1;
                iesData.data.forEach((row) => {
                    tableHTML += `<tr>
            <td>${numberRow}</td>
            <td>${row.index_data ?? ''}</td>
            <td>${row.row_text ? row.row_text.text_data : ''}</td>`;

                    if (row.floats) {
                        row.floats.forEach(f => {
                            tableHTML += `<td>${f.float_data}</td>`;
                        });
                    }

                    if (row.texts) {
                        row.texts.forEach(t => {
                            tableHTML += `<td>${t.text_data}</td>`;
                        });
                    }

                    tableHTML += `</tr>`;
                    numberRow++;
                });

                tableHTML += `
                </tbody>
            </table>
        </div>
    </div>
    `;

                previewContent.innerHTML = tableHTML;

                // Proper cleanup
                this.currentCleanup = () => {
                    previewContent.innerHTML = "";
                };
            }



            renderTextContent(text, filePath) {

                const previewContent = document.getElementById('previewContent');
                const extension = filePath.split('.').pop().toLowerCase();

                // Map extensions to Prism languages or plain text
                const extensionMap = {
                    // XML-like files
                    xml: 'markup',
                    skn: 'markup',
                    '3dprop': 'markup',
                    '3dworld': 'markup',
                    '3drender': 'markup',
                    '3deffect': 'markup',
                    sani: 'markup',
                    effect: 'markup',
                    atlas: 'markup',
                    sprbin: 'markup',
                    xsd: 'markup',

                    // C++ style files
                    x: 'cpp',
                    fx: 'glsl',
                    fxh: 'glsl',
                    export: 'cpp',

                    // JSON files
                    json: 'json',

                    // Lua files
                    lua: 'lua',

                    // Plain text
                    lst: 'none',
                    txt: 'none',
                };

                const prismLang = extensionMap[extension] || 'none';

                previewContent.innerHTML = `
        <div class="bg-dark p-3 rounded" 
             style="background-color: rgba(0,0,0,0.5) !important; overflow:auto;">
            <pre style="color: #ffffff; margin: 0; white-space: pre-wrap; word-wrap: break-word;">
                <code class="${prismLang !== 'none' ? 'language-' + prismLang : ''}">
${this.escapeHtml(text)}
                </code>
            </pre>
        </div>
    `;
                // Apply Prism highlighting if language is not plain text
                if (window.Prism && prismLang !== 'none') {
                    Prism.highlightAllUnder(previewContent);
                }

                // Proper cleanup
                this.currentCleanup = () => {
                    previewContent.innerHTML = "";
                };
            }


            renderMP3Audio(blob) {

                const previewContent = document.getElementById('previewContent');
                const audioUrl = URL.createObjectURL(blob);

                previewContent.innerHTML = `
        <div class="stat-card">
            <div class="text-center">
                <audio controls class="w-100 mt-3 shadow rounded">
                    <source src="${audioUrl}" type="${blob.type || 'audio/mpeg'}">
                    Your browser does not support the audio element.
                </audio>
            </div>
        </div>
    `;

                // Add debug info
                const debugInfo = document.createElement('div');
                debugInfo.className = 'mt-3 p-3';
                debugInfo.style.background = 'rgba(255, 255, 255, 0.05)';
                debugInfo.style.borderRadius = '8px';
                debugInfo.style.fontSize = '0.85rem';
                debugInfo.innerHTML = `
        <div class="text-light">
            <strong>Audio Debug Information:</strong><br>
            <span style="color: #4a90e2;">Format:</span> ${blob.type || 'Unknown'}<br>
            <span style="color: #4a90e2;">File Size:</span> ${this.formatBytes(blob.size)}<br>
            <span style="color: #4a90e2;">Duration:</span> <span id="audioDuration">Loading...</span>
        </div>
    `;
                previewContent.appendChild(debugInfo);

                // Get audio element and load metadata
                const audioElement = previewContent.querySelector('audio');
                audioElement.onloadedmetadata = () => {
                    const durationElem = document.getElementById('audioDuration');
                    durationElem.textContent = this.formatTime(audioElement.duration);
                };

                // Cleanup
                this.currentCleanup = () => {
                    if (audioElement) {
                        audioElement.pause();
                        audioElement.src = "";
                    }
                    URL.revokeObjectURL(audioUrl);
                    previewContent.innerHTML = ""; // clear DOM
                };
            }

            // Helper to format seconds into mm:ss
            formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }



            renderImageContent(blob) {

                const previewContent = document.getElementById('previewContent');
                const imageUrl = URL.createObjectURL(blob);

                let img = new Image();

                img.onload = () => {
                    previewContent.innerHTML = `
            <div class="stat-card">
                <div class="text-center">
                    <img src="${imageUrl}" class="img-fluid rounded shadow" style="max-height: 70vh;" alt="Preview">
                </div>
            </div>
        `;

                    // Debug info
                    const debugInfo = document.createElement('div');
                    debugInfo.className = 'mt-3 p-3';
                    debugInfo.style.background = 'rgba(255, 255, 255, 0.05)';
                    debugInfo.style.borderRadius = '8px';
                    debugInfo.style.fontSize = '0.85rem';
                    debugInfo.innerHTML = `
            <div class="text-light">
                <strong>Image Debug Information:</strong><br>
                <span style="color: #4a90e2;">Dimensions:</span> ${img.naturalWidth} x ${img.naturalHeight}<br>
                <span style="color: #4a90e2;">Format:</span> ${blob.type || 'Unknown'}<br>
                <span style="color: #4a90e2;">File Size:</span> ${this.formatBytes(blob.size)}<br>
                <span style="color: #4a90e2;">Aspect Ratio:</span> ${(img.naturalWidth / img.naturalHeight).toFixed(3)}
            </div>
        `;
                    previewContent.appendChild(debugInfo);
                };

                img.onerror = () => {
                    previewContent.innerHTML = `
            <div class="text-center text-danger p-4">
                <i class="bi bi-exclamation-triangle" style="font-size: 3rem;"></i>
                <h5 class="mt-3">Error Loading Image</h5>
                <p>Failed to decode image format</p>
            </div>
        `;
                };

                img.src = imageUrl;

                // Cleanup
                this.currentCleanup = () => {
                    if (img) {
                        img.src = ""; // release image reference
                        img = null;
                    }
                    URL.revokeObjectURL(imageUrl);
                    previewContent.innerHTML = ""; // clear preview
                };
            }



            renderDDSContent(arrayBuffer) {

                const previewContent = document.getElementById('previewContent');

                // Hold references for cleanup
                let canvas = null;
                let gl = null;
                let texture = null;
                let buf = null;
                let vs = null;
                let fs = null;
                let prog = null;

                try {
                    const DDS_MAGIC = 0x20534444; // "DDS "
                    const DDS_DX10 = 0x30315844; // "DX10"

                    if (arrayBuffer.byteLength < 128) throw new Error('Invalid DDS file size');

                    const dds = new DataView(arrayBuffer);
                    const magic = dds.getUint32(0, true);
                    if (magic !== DDS_MAGIC) throw new Error('Invalid DDS header');

                    const height = dds.getUint32(12, true);
                    const width = dds.getUint32(16, true);
                    const fourCC = dds.getUint32(84, true);
                    let offset = 128;
                    let format = null;
                    let blockSize = 0;
                    let uncompressed = false;
                    let bytesPerPixel = 4; // default RGBA

                    // DX10 header
                    if (fourCC === DDS_DX10) {
                        if (arrayBuffer.byteLength < offset + 20) throw new Error('Invalid DDS DX10 file');
                        const dxgiFormat = dds.getUint32(offset, true);
                        offset += 20;

                        switch (dxgiFormat) {
                            case 71: format = 'COMPRESSED_RGBA_S3TC_DXT1_EXT'; blockSize = 8; break;
                            case 74: format = 'COMPRESSED_RGBA_S3TC_DXT3_EXT'; blockSize = 16; break;
                            case 77: format = 'COMPRESSED_RGBA_S3TC_DXT5_EXT'; blockSize = 16; break;
                            default: throw new Error('Unsupported DX10 DDS format');
                        }
                    } else {
                        // Legacy
                        switch (fourCC) {
                            case 0x31545844: format = 'COMPRESSED_RGBA_S3TC_DXT1_EXT'; blockSize = 8; break; // DXT1
                            case 0x33545844: format = 'COMPRESSED_RGBA_S3TC_DXT3_EXT'; blockSize = 16; break; // DXT3
                            case 0x35545844: format = 'COMPRESSED_RGBA_S3TC_DXT5_EXT'; blockSize = 16; break; // DXT5
                            case 0: // uncompressed
                                format = 'UNCOMPRESSED';
                                uncompressed = true;
                                bytesPerPixel = dds.getUint32(88, true) / 8; // dwRGBBitCount
                                break;
                            default:
                                throw new Error('Unsupported legacy DDS format');
                        }
                    }

                    // Setup canvas
                    // Setup stat card container
                    previewContent.innerHTML = `
    <div class="stat-card">
        <div class="text-center">
            <canvas id="ddsCanvas" class="rounded shadow" 
                style="max-height: 70vh; background:#111; display:block; margin:0 auto;">
            </canvas>
        </div>
    </div>
`;

                    canvas = document.getElementById('ddsCanvas');
                    canvas.width = width;
                    canvas.height = height;

                    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!gl) throw new Error('WebGL not supported');

                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                    texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);

                    if (uncompressed) {
                        const pixelData = new Uint8Array(arrayBuffer, offset, width * height * bytesPerPixel);
                        gl.texImage2D(
                            gl.TEXTURE_2D,
                            0,
                            bytesPerPixel === 4 ? gl.RGBA : gl.RGB,
                            width,
                            height,
                            0,
                            bytesPerPixel === 4 ? gl.RGBA : gl.RGB,
                            gl.UNSIGNED_BYTE,
                            pixelData
                        );
                    } else {
                        const ext = gl.getExtension('WEBGL_compressed_texture_s3tc') ||
                            gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                            gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                        if (!ext) throw new Error('S3TC compression not supported');

                        const formatMap = {
                            'COMPRESSED_RGBA_S3TC_DXT1_EXT': ext.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                            'COMPRESSED_RGBA_S3TC_DXT3_EXT': ext.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                            'COMPRESSED_RGBA_S3TC_DXT5_EXT': ext.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        };

                        const glFormat = formatMap[format];
                        const imageSize = Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * blockSize;
                        const textureData = new Uint8Array(arrayBuffer, offset, imageSize);
                        gl.compressedTexImage2D(gl.TEXTURE_2D, 0, glFormat, width, height, 0, textureData);
                    }

                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    // Shaders
                    vs = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(vs, `
            attribute vec2 pos;
            attribute vec2 uv;
            varying vec2 vUV;
            void main() {
                vUV = uv;
                gl_Position = vec4(pos, 0.0, 1.0);
            }
        `);
                    gl.compileShader(vs);

                    fs = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(fs, `
            precision mediump float;
            varying vec2 vUV;
            uniform sampler2D tex;
            void main() {
                gl_FragColor = texture2D(tex, vUV);
            }
        `);
                    gl.compileShader(fs);

                    prog = gl.createProgram();
                    gl.attachShader(prog, vs);
                    gl.attachShader(prog, fs);
                    gl.linkProgram(prog);
                    gl.useProgram(prog);

                    const verts = new Float32Array([
                        -1, -1, 0, 1,
                        1, -1, 1, 1,
                        -1, 1, 0, 0,
                        1, 1, 1, 0
                    ]);
                    buf = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                    gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);

                    const posLoc = gl.getAttribLocation(prog, 'pos');
                    const uvLoc = gl.getAttribLocation(prog, 'uv');

                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
                    gl.enableVertexAttribArray(uvLoc);
                    gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 16, 8);

                    gl.uniform1i(gl.getUniformLocation(prog, 'tex'), 0);

                    gl.viewport(0, 0, width, height);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    // Debug Info
                    const debugInfo = document.createElement('div');
                    debugInfo.className = 'mt-3 p-3';
                    debugInfo.style.background = 'rgba(255, 255, 255, 0.05)';
                    debugInfo.style.borderRadius = '8px';
                    debugInfo.style.fontSize = '0.85rem';
                    debugInfo.innerHTML = `
            <div class="text-light">
                <strong>DDS Debug Information:</strong><br>
                <span style="color: #FFA500;">Dimensions:</span> ${width} x ${height}<br>
                <span style="color: #FFA500;">Format:</span> ${format}<br>
                ${uncompressed
                            ? `<span style="color: #FFA500;">Bytes Per Pixel:</span> ${bytesPerPixel}<br>`
                            : `<span style="color: #FFA500;">Block Size:</span> ${blockSize} bytes<br>`}
                <span style="color: #FFA500;">Data Offset:</span> ${offset} bytes<br>
                <span style="color: #FFA500;">Total File Size:</span> ${arrayBuffer.byteLength} bytes<br>
                <span style="color: #FFA500;">FourCC:</span> 0x${fourCC.toString(16).toUpperCase()}<br>
                <span style="color: #FFA500;">Header Type:</span> ${fourCC === DDS_DX10 ? 'DX10 Extended' : 'Legacy'}
            </div>
        `;
                    previewContent.appendChild(debugInfo);

                } catch (error) {
                    previewContent.innerHTML = `
            <div class="text-center text-danger p-4">
                <i class="bi bi-exclamation-triangle" style="font-size: 3rem;"></i>
                <h5 class="mt-3">Error Loading DDS</h5>
                <p>${error.message}</p>
            </div>
        `;
                }

                // Cleanup function
                this.currentCleanup = () => {
                    if (gl) {
                        if (texture) gl.deleteTexture(texture);
                        if (buf) gl.deleteBuffer(buf);
                        if (vs) gl.deleteShader(vs);
                        if (fs) gl.deleteShader(fs);
                        if (prog) gl.deleteProgram(prog);

                        gl.getExtension('WEBGL_lose_context')?.loseContext();
                    }

                    if (canvas && canvas.parentNode) {
                        canvas.parentNode.removeChild(canvas);
                    }

                    // Nullify refs
                    canvas = gl = texture = buf = vs = fs = prog = null;
                };
            }



            async searchFiles(query) {
                if (!query.trim()) {
                    this.loadRootFolders();
                    return;
                }

                try {
                    const response = await fetch(`/api/file/search?file_name=${encodeURIComponent(query)}`);
                    if (!response.ok) throw new Error('Search failed');

                    const data = await response.json();
                    this.renderSearchResults(data);
                } catch (error) {
                    console.error('Search error:', error);
                }
            }

            renderSearchResults(searchData) {
                const container = document.getElementById('fileTree');
                container.innerHTML = '';

                if (searchData.found_files.length === 0) {
                    container.innerHTML = `
                        <div class="text-light p-3">
                            <i class="bi bi-search"></i>
                            No files found matching "${searchData.file_name}"
                        </div>
                    `;
                    return;
                }

                // Group files by unique path, keeping all versions
                const groupedFiles = new Map();
                searchData.found_files.forEach(file => {
                    const key = file.file_path;
                    if (!groupedFiles.has(key)) {
                        groupedFiles.set(key, []);
                    }
                    groupedFiles.get(key).push(file);
                });

                const header = document.createElement('div');
                header.className = 'p-3 border-bottom';
                header.innerHTML = `
                    <small class="text-light">
                        Found ${groupedFiles.size} unique file(s) (${searchData.found_files.length} total versions) for "${searchData.file_name}"
                    </small>
                `;
                container.appendChild(header);

                // Sort grouped files by path case-insensitively
                const sortedEntries = Array.from(groupedFiles.entries()).sort((a, b) =>
                    a[0].toLowerCase().localeCompare(b[0].toLowerCase())
                );

                sortedEntries.forEach(([filePath, versions]) => {
                    const element = document.createElement('div');
                    element.className = 'tree-item file';

                    const fileName = filePath.split('/').pop();
                    const ext = fileName.split('.').pop().toLowerCase();
                    const iconClass = this.getFileIcon(ext);

                    element.innerHTML = `
                        <i class="bi ${iconClass} file-icon ${ext}"></i>
                        <div style="flex: 1;">
                            <div class="text-light">${fileName}</div>
                            <small class="text-light">${filePath} (${versions.length} version${versions.length > 1 ? 's' : ''})</small>
                        </div>
                    `;

                    element.addEventListener('click', async () => {
                        document.querySelectorAll('.tree-item.selected').forEach(item => {
                            item.classList.remove('selected');
                        });
                        element.classList.add('selected');

                        await this.loadFileInfo(filePath);
                    });

                    container.appendChild(element);
                });
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }
        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ArchiveViewer();
        });

        // Handle panel resizing
        document.addEventListener('DOMContentLoaded', () => {
            const panels = document.querySelectorAll('.tree-panel, .info-panel');

            panels.forEach(panel => {
                let isResizing = false;

                panel.addEventListener('mousedown', (e) => {
                    if (e.offsetX > panel.offsetWidth - 10) {
                        isResizing = true;
                        document.body.style.cursor = 'col-resize';
                        e.preventDefault();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (isResizing) {
                        const newWidth = e.clientX - panel.offsetLeft;
                        if (newWidth >= 250 && newWidth <= 500) {
                            panel.style.width = newWidth + 'px';
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = 'default';
                    }
                });
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+F for search
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                document.getElementById('fileSearch').focus();
            }

            // Escape to clear search
            if (e.key === 'Escape') {
                const searchInput = document.getElementById('fileSearch');
                if (searchInput === document.activeElement) {
                    searchInput.value = '';
                    searchInput.blur();
                    window.archiveViewer?.loadRootFolders();
                }
            }
        });
    </script>
</body>

</html>