<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.11.1/font/bootstrap-icons.min.css"
        rel="stylesheet">

    <!-- Prism.js CSS for styling -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <!-- Prism.js JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-xml-doc.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-lua.min.js"></script>
    <!-- Add more languages as needed -->
    <!-- C/C++ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-glsl.min.js"></script>

    <style>
        body {
            background-color: #0f0f23;
            color: #cccccc;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        .main-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .content-area {
            flex: 1;
            display: flex;
            min-height: 0;
        }

        .tree-panel {
            width: 400px;
            min-width: 250px;
            max-width: 500px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            resize: horizontal;
            overflow: hidden;
        }

        .tree-header {
            background: linear-gradient(90deg, #0f3460 0%, #16537e 100%);
            padding: 15px;
            border-bottom: 1px solid #333;
        }

        .tree-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .preview-panel {
            flex: 1;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .preview-header {
            background: linear-gradient(90deg, #16537e 0%, #0f3460 100%);
            padding: 15px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: between;
            align-items: center;
        }

        .preview-content {
            flex: 1;
            padding: 20px;
            overflow: auto;
        }

        .preview-xac {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 70vh;
            overflow: hidden;
        }


        .info-panel {
            width: 350px;
            min-width: 300px;
            max-width: 500px;
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            resize: horizontal;
            overflow: hidden;
        }

        .info-header {
            background: linear-gradient(90deg, #0f3460 0%, #16537e 100%);
            padding: 15px;
            border-bottom: 1px solid #333;
        }

        .info-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        /* Tree Styles */
        .tree-item {
            padding: 8px 12px;
            margin: 2px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: normal;
            /* allow wrapping */
            word-break: break-word;
            /* break long words if needed */
            overflow-wrap: break-word;
            /* fallback for older browsers */
        }

        .tree-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(3px);
        }

        .tree-item.selected {
            background: linear-gradient(90deg, #4a90e2 0%, #357abd 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(74, 144, 226, 0.3);
        }

        .tree-item.folder {
            color: #4a90e2;
            font-weight: 500;
        }

        .tree-item.file {
            color: #ffffff;
            padding-left: 24px;
        }

        .tree-item i {
            font-size: 14px;
            width: 16px;
            text-align: center;
        }

        /* Search Box */
        .search-box {
            position: sticky;
            top: 0;
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
        }

        .search-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #333;
            border-radius: 8px;
            color: #cccccc;
            width: 100%;
            padding: 8px 12px;
        }

        .search-input:focus {
            border-color: #4a90e2;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
            outline: none;
            background: rgba(255, 255, 255, 0.15);
        }

        /* IES Table Styles */
        .ies-table {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .ies-table table {
            margin: 0;
        }

        .ies-table th {
            background: linear-gradient(90deg, #16537e 0%, #0f3460 100%);
            color: white;
            padding: 12px;
            font-weight: 600;
            border: none;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .ies-table td {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            color: #ffffff;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
        }

        .ies-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        /* Statistics Cards */
        .stat-card {
            background: linear-gradient(135deg, rgba(74, 144, 226, 0.1) 0%, rgba(53, 122, 189, 0.1) 100%);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            transition: transform 0.2s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(74, 144, 226, 0.2);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4a90e2;
        }

        .stat-label {
            color: #b0b0b0;
            font-size: 0.9rem;
        }

        /* Tree Collapse Styles */
        .tree-children {
            margin-left: 20px;
            overflow: hidden;
            transform-origin: top;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out, background-color 0.3s ease-out;
            transform: scaleY(0);
            opacity: 0;
        }

        /* Expanded subfolders */
        .tree-children.expanded {
            transform: scaleY(1);
            opacity: 1;
            background-color: rgba(38, 56, 108, 0.6);
            /* slightly darker */
            border-radius: 4px;
            padding-left: 10px;
        }



        .file-icon {
            color: #666;
        }

        .file-icon.ies {
            color: #f39c12;
        }

        .file-icon.xml {
            color: #e74c3c;
        }

        .file-icon.lua {
            color: #9b59b6;
        }

        .file-icon.png,
        .file-icon.jpg,
        .file-icon.jpeg,
        .file-icon.bmp,
        .file-icon.tga {
            color: #2ecc71;
        }

        /* Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid rgba(74, 144, 226, 0.3);
            border-top: 3px solid #4a90e2;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #357abd 0%, #2e6da4 100%);
        }

        /* Navigation Header */
        .navbar {
            background: linear-gradient(90deg, #0f3460 0%, #16537e 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .navbar-brand {
            color: white !important;
            font-weight: bold;
            font-size: 1.3rem;
        }

        /* Breadcrumb */
        .breadcrumb-container {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 15px;
            border-bottom: 1px solid #333;
        }

        .breadcrumb {
            margin: 0;
            background: none;
        }

        .breadcrumb-item a {
            color: #4a90e2;
            text-decoration: none;
        }

        .breadcrumb-item a:hover {
            color: #357abd;
        }

        .breadcrumb-item.active {
            color: #ffffff;
        }

        /* Version Selector */
        .version-selector {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #333;
            border-radius: 6px;
            color: #cccccc;
            padding: 5px 10px;
            font-size: 0.9rem;
        }

        .version-selector:focus {
            border-color: #4a90e2;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
            outline: none;
        }
    </style>
</head>

<body>


    <div class="main-container">
        <!-- Navigation Header -->
        <nav class="navbar navbar-expand-lg">
            <div class="container-fluid">
                <a class="navbar-brand" href="/home">
                    <i class="bi bi-archive"></i>
                    Tree of Savior Archive Viewer
                </a>
                <div class="d-flex align-items-center text-light">
                    <small class="me-3">
                        <i class="bi bi-files"></i>
                        {{ count_unique }} files
                    </small>
                    <small>
                        <i class="bi bi-hdd"></i>
                        Ready
                    </small>
                </div>
            </div>
        </nav>

        <div class="content-area">
            <!-- Left Panel - File Tree -->
            <div class="tree-panel">
                <div class="tree-header">
                    <h6 class="mb-0">
                        <i class="bi bi-folder-open"></i>
                        File Browser
                    </h6>
                </div>

                <div class="search-box input-group">
                    <input type="text" class="form-control search-input  bg-dark text-light"
                        placeholder="Search files..." id="fileSearch">
                    <button class="btn btn-primary" id="searchBtn">
                        <i class="bi bi-search"></i>
                    </button>
                </div>


                <div class="tree-content" id="fileTree">
                    <div class="loading">
                        <div class="spinner"></div>
                        Loading file tree...
                    </div>
                </div>
            </div>

            <!-- Middle Panel - Preview -->
            <div class="preview-panel">
                <div class="preview-header">
                    <div>
                        <h6 class="mb-0" id="previewTitle">
                            <i class="bi bi-eye"></i>
                            Preview
                        </h6>
                        <div class="breadcrumb-container">
                            <nav aria-label="breadcrumb">
                                <ol class="breadcrumb" id="breadcrumb">
                                    <li class="breadcrumb-item active">Select a file to preview</li>
                                </ol>
                            </nav>
                        </div>
                    </div>
                    <div id="versionControls" style="display: none;">
                        <select class="version-selector" id="versionSelect">
                            <option value="0">Version 1</option>
                        </select>
                    </div>
                </div>

                <div class="preview-content" id="previewContent">
                    <div class="text-center text-light mt-5">
                        <i class="bi bi-file-earmark" style="font-size: 4rem; opacity: 0.3;"></i>
                        <h5 class="mt-3">No file selected</h5>
                        <p>Select a file from the tree to preview its contents</p>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Information -->
            <div class="info-panel">
                <div class="info-header">
                    <h6 class="mb-0">
                        <i class="bi bi-info-circle"></i>
                        Information
                    </h6>
                </div>

                <div class="info-content">

                    <!-- File Information Panel -->
                    <div id="fileInfo" style="display: none;">
                        <h6 class="mt-4 mb-3">File Details</h6>
                        <div id="fileDetails"></div>
                    </div>


                    <!-- General Stats -->
                    <h6 class="mt-4 mb-3">General Stats</h6>
                    <div class="stat-card">
                        <div class="stat-value">{{ count_unique }}</div>
                        <div class="stat-label">Unique Files</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ count_duplicated }}</div>
                        <div class="stat-label">Duplicated Files</div>
                    </div>


                    <!-- File Size Stats -->
                    <h6 class="mt-4 mb-3">File Size (Compressed)</h6>
                    <div class="stat-card">
                        <div class="stat-value">{{ compressed_lowest }}</div>
                        <div class="stat-label">Lowest</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ compressed_avg }}</div>
                        <div class="stat-label">Average</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ compressed_highest }}</div>
                        <div class="stat-label">Highest</div>
                    </div>

                    <h6 class="mt-4 mb-3">File Size (Uncompressed)</h6>
                    <div class="stat-card">
                        <div class="stat-value">{{ uncompressed_lowest }}</div>
                        <div class="stat-label">Lowest</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ uncompressed_avg }}</div>
                        <div class="stat-label">Average</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">{{ uncompressed_highest }}</div>
                        <div class="stat-label">Highest</div>
                    </div>

                    <!-- Duplicate Statistics -->
                    <h6 class="mt-4 mb-3">Duplicate Statistics</h6>
                    <div class="stat-card">
                        <div class="stat-value">{{ duplicates_xac + duplicates_xsm + duplicates_xsmtime + duplicates_xpm
                            + duplicates_dds }}</div>
                        <div class="stat-label">Total Duplicates</div>
                    </div>

                    <div class="row g-2">
                        <div class="col-6">
                            <div class="stat-card">
                                <div class="stat-value">{{ duplicates_xac }}</div>
                                <div class="stat-label">XAC</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="stat-card">
                                <div class="stat-value">{{ duplicates_xsm }}</div>
                                <div class="stat-label">XSM</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="stat-card">
                                <div class="stat-value">{{ duplicates_xsmtime }}</div>
                                <div class="stat-label">XSM Time</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="stat-card">
                                <div class="stat-value">{{ duplicates_xpm }}</div>
                                <div class="stat-label">XPM</div>
                            </div>
                        </div>
                        <div class="col-12">
                            <div class="stat-card">
                                <div class="stat-value">{{ duplicates_dds }}</div>
                                <div class="stat-label">DDS</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/js/bootstrap.bundle.min.js"></script>
    <script>
        class ArchiveViewer {
            constructor() {
                this.currentFolder = "";
                this.currentFile = null;
                this.fileVersions = [];
                this.selectedVersion = 0;
                this.init();
            }

            init() {
                this.loadRootFolders();
                this.setupEventListeners();
            }

            setupEventListeners() {

                // Version selector
                document.getElementById('versionSelect').addEventListener('change', (e) => {
                    this.selectedVersion = parseInt(e.target.value);

                    // Load the preview
                    this.loadFilePreview(this.currentFile, this.selectedVersion);

                    // Update file info for the selected version
                    const fileInfo = this.fileVersions[this.selectedVersion] || this.fileVersions[0];
                    this.updateFileDetails(fileInfo);
                });

                document.getElementById('searchBtn').addEventListener('click', () => {
                    const query = document.getElementById('fileSearch').value;
                    this.searchFiles(query);
                });

                // Optional: also trigger search on Enter key
                document.getElementById('fileSearch').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault(); // prevents accidental form submit if inside a form
                        const query = e.target.value;
                        this.searchFiles(query);
                    }
                });


            }



            async loadRootFolders() {
                try {
                    const response = await fetch('/api/folder/shallow?folder_name=');
                    if (!response.ok) throw new Error('Failed to load root folders');

                    const data = await response.json();
                    this.renderFolderTree(data);
                } catch (error) {
                    document.getElementById('fileTree').innerHTML = `
                        <div class="text-danger p-3">
                            <i class="bi bi-exclamation-triangle"></i>
                            Error loading file tree: ${error.message}
                        </div>
                    `;
                }
            }

            async loadFolder(folderName) {
                try {
                    const response = await fetch(`/api/folder/shallow?folder_name=${encodeURIComponent(folderName)}`);
                    if (!response.ok) throw new Error('Failed to load folder');

                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error loading folder:', error);
                    return null;
                }
            }

            renderFolderTree(data, parentElement = null) {
                const container = parentElement || document.getElementById('fileTree');
                container.innerHTML = '';


                // Sort subfolders naturally, case-insensitive
                const sortedSubfolders = [...data.subfolders].sort((a, b) =>
                    a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })
                );

                // Sort files naturally, case-insensitive
                const sortedFiles = [...data.files].sort((a, b) =>
                    a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })
                );


                // Render sorted subfolders
                sortedSubfolders.forEach(folder => {
                    const folderElement = this.createFolderElement(folder, data.folder_name);
                    container.appendChild(folderElement);
                });

                // Render sorted files
                sortedFiles.forEach(file => {
                    const fileElement = this.createFileElement(file, data.folder_name);
                    container.appendChild(fileElement);
                });
            }

            createFolderElement(folderName, parentPath) {
                const element = document.createElement('div');
                element.className = 'tree-item folder';
                element.innerHTML = `
                    <i class="bi bi-folder"></i>
                    <span>${folderName}</span>
                `;

                let childContainer = null;
                let isExpanded = false;

                element.addEventListener('click', async () => {
                    if (isExpanded) {
                        // Collapse folder
                        isExpanded = false;
                        element.querySelector('i').className = 'bi bi-folder';
                        if (childContainer) {
                            childContainer.classList.remove('expanded');
                            childContainer.classList.add('collapsed');
                            setTimeout(() => {
                                childContainer.remove();
                                childContainer = null;
                            }, 300);
                        }
                    } else {
                        // Expand folder
                        isExpanded = true;
                        element.querySelector('i').className = 'bi bi-folder-open';

                        const fullPath = parentPath ? `${parentPath}/${folderName}` : folderName;
                        const folderData = await this.loadFolder(fullPath);

                        if (folderData) {
                            // Create container for children
                            childContainer = document.createElement('div');
                            childContainer.className = 'tree-children collapsed';



                            // Sort subfolders naturally, case-insensitive
                            const sortedSubfolders = [...folderData.subfolders].sort((a, b) =>
                                a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })
                            );

                            // Sort files naturally, case-insensitive
                            const sortedFiles = [...folderData.files].sort((a, b) =>
                                a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })
                            );


                            // Add sorted subfolders
                            sortedSubfolders.forEach(subfolder => {
                                const subfolderElement = this.createFolderElement(subfolder, fullPath);
                                childContainer.appendChild(subfolderElement);
                            });

                            // Add sorted files
                            sortedFiles.forEach(file => {
                                const fileElement = this.createFileElement(file, fullPath);
                                childContainer.appendChild(fileElement);
                            });

                            // Insert after current folder
                            element.parentNode.insertBefore(childContainer, element.nextSibling);

                            // Trigger expansion animation
                            setTimeout(() => {
                                childContainer.classList.remove('collapsed');
                                childContainer.classList.add('expanded');
                            }, 10);
                        }
                    }
                });

                return element;
            }

            createFileElement(fileName, parentPath) {
                const element = document.createElement('div');
                element.className = 'tree-item file';

                const ext = fileName.split('.').pop().toLowerCase();
                const iconClass = this.getFileIcon(ext);

                element.innerHTML = `
                    <i class="bi ${iconClass} file-icon ${ext}"></i>
                    <span>${fileName}</span>
                `;

                element.addEventListener('click', () => {
                    // Remove previous selection
                    document.querySelectorAll('.tree-item.selected').forEach(item => {
                        item.classList.remove('selected');
                    });

                    // Select this item
                    element.classList.add('selected');

                    const fullPath = parentPath ? `${parentPath}/${fileName}` : fileName;
                    this.loadFileInfo(fullPath);

                    this.selectedVersion = 0;

                    // Load the preview
                    this.loadFilePreview(this.currentFile, this.selectedVersion);

                    // Update file info for the selected version
                    const fileInfo = this.fileVersions[this.selectedVersion] || this.fileVersions[0];
                    this.updateFileDetails(fileInfo);
                });

                return element;
            }

            getFileIcon(extension) {
                const icons = {
                    'ies': 'bi-table',
                    'xml': 'bi-code-slash',
                    'skn': 'bi-code-slash',
                    '3deffect': 'bi-code-slash',
                    '3dprop': 'bi-code-slash',
                    '3dworld': 'bi-code-slash',
                    '3drender': 'bi-code-slash',
                    'fx': 'bi-code-slash',
                    'fxh': 'bi-code-slash',
                    'x': 'bi-code-slash',
                    'sani': 'bi-code-slash',
                    'effect': 'bi-code-slash',
                    'sprbin': 'bi-code-slash',
                    'lua': 'bi-file-code',
                    'png': 'bi-image',
                    'jpg': 'bi-image',
                    'jpeg': 'bi-image',
                    'bmp': 'bi-image',
                    'tga': 'bi-image',
                    'txt': 'bi-file-text'
                };
                return icons[extension] || 'bi-file-earmark';
            }

            async loadFileInfo(filePath) {
                try {
                    this.currentFile = filePath;

                    // Load file versions
                    const response = await fetch(`/api/file/fullpath?full_path=${encodeURIComponent(filePath)}`);
                    if (!response.ok) throw new Error('File not found');

                    this.fileVersions = await response.json();
                    this.updateVersionSelector();
                    this.updateBreadcrumb(filePath);
                    this.updateFileDetails(this.fileVersions[0]);
                    this.loadFilePreview(filePath, 0);

                } catch (error) {
                    console.error('Error loading file info:', error);
                    this.showError('Failed to load file information');
                }
            }

            updateVersionSelector() {
                const selector = document.getElementById('versionSelect');
                const controls = document.getElementById('versionControls');

                if (this.fileVersions.length > 1) {
                    controls.style.display = 'block';
                    selector.innerHTML = this.fileVersions.map((version, index) =>
                        `<option value="${index}">Version ${index + 1}</option>`
                    ).join('');
                } else {
                    controls.style.display = 'none';
                }
            }

            updateBreadcrumb(filePath) {
                const breadcrumb = document.getElementById('breadcrumb');
                const parts = filePath.split('/');

                breadcrumb.innerHTML = parts.map((part, index) => {
                    if (index === parts.length - 1) {
                        return `<li class="breadcrumb-item active">${part}</li>`;
                    } else {
                        return `<li class="breadcrumb-item"><a href="#">${part}/</a></li>`;
                    }
                }).join('');
            }

            updateFileDetails(fileInfo) {
                document.getElementById('fileInfo').style.display = 'block';

                const details = document.getElementById('fileDetails');
                details.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">Container</div>
                        <div class="stat-value" style="font-size: 1rem;">${fileInfo.container_name}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Compressed Size</div>
                        <div class="stat-value" style="font-size: 1rem;">${this.formatBytes(fileInfo.file_size_compressed)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Uncompressed Size</div>
                        <div class="stat-value" style="font-size: 1rem;">${this.formatBytes(fileInfo.file_size_uncompressed)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">CRC32</div>
                        <div class="stat-value" style="font-size: 1rem;">${fileInfo.crc32.toString(16).toUpperCase()}</div>
                    </div>
                        <div class="stat-card">
                        <div class="stat-label">File Path</div>
                        <div class="stat-value" style="font-size: 1rem;">${fileInfo.file_path.toString()}</div>
                    </div>
                    <div class="stat-card d-flex justify-content-center align-items-center" style="height: 100px;">
                        <a href="/api/file/download?path=${encodeURIComponent(this.currentFile)}&version=${this.selectedVersion || 0}" 
                        class="btn btn-primary">
                        <i class="bi bi-download"></i>
                            Download File Raw
                        </a>
                    </div>

                `;
            }

            async loadFilePreview(filePath, version = 0) {
                const previewContent = document.getElementById('previewContent');
                previewContent.classList.remove("preview-xac"); // revert
                previewContent.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        Loading preview...
                    </div>
                `;

                try {
                    const response = await fetch(`/api/file/preview?path=${encodeURIComponent(filePath)}&version=${version}`);

                    if (!response.ok) throw new Error('Failed to load preview');

                    const contentType = response.headers.get('content-type');
                    const extension = filePath.split('.').pop().toLowerCase();

                    if (contentType.includes('application/json') && extension === 'ies') {
                        // Only treat JSON as IES if the file extension is .ies
                        const iesData = await response.json();
                        this.renderIESTable(iesData);
                    } else if (contentType.includes('audio') && extension === 'mp3') {
                        const mp3Data = await response.blob();
                        this.renderMP3Audio(mp3Data);
                    } else if (contentType.includes('application/json') && extension === 'xac') {
                        const xacData = await response.json();
                        this.renderXACModel(xacData);
                    } else if (contentType.includes('text/plain')) {
                        // Text file - render as code
                        let text = await response.text(); // use let, not const

                        const extension = filePath.split('.').pop().toLowerCase();
                        if (extension === 'json') {
                            try {
                                text = JSON.stringify(JSON.parse(text), null, 2); // 2-space indent
                            } catch (e) {
                                // fallback if JSON is invalid
                            }
                        }

                        this.renderTextContent(text, filePath);
                    } else if (contentType.includes('image/') && (filePath.toLowerCase().endsWith('.dds') || contentType.includes('dds'))) {
                        // DDS: fetch as ArrayBuffer and render with WebGL compressed texture support
                        const arrayBuffer = await response.arrayBuffer();
                        this.renderDDSContent(arrayBuffer);
                    } else if (contentType.includes('image/')) {
                        // Image file - render as image
                        const blob = await response.blob();
                        this.renderImageContent(blob);
                    } else if (contentType.includes('font/')) {
                        // Font file - render as text
                        const blob = await response.blob();
                        this.renderFontContent(blob);
                    } else {
                        // Binary file - show download option
                        this.renderBinaryContent(filePath, version);
                    }

                } catch (error) {
                    this.showError('Failed to load file preview');
                }
            }


            renderFontContent(blob) {

                const previewContent = document.getElementById('previewContent');
                previewContent.innerHTML = ''; // clear previous content

                // Create a URL for the font file
                const fontUrl = URL.createObjectURL(blob);
                const fontName = 'PreviewFont';

                // Create @font-face style
                const style = document.createElement('style');
                style.innerHTML = `
        @font-face {
            font-family: '${fontName}';
            src: url('${fontUrl}');
        }
    `;
                document.head.appendChild(style);

                // Create a text input for live preview
                const input = document.createElement('input');
                input.type = 'text';
                input.value = 'The quick brown fox jumps over the lazy dog';
                input.style.width = '100%';
                input.style.marginBottom = '10px';
                input.style.padding = '8px';
                input.style.fontSize = '1.2rem';

                // Create preview div
                const preview = document.createElement('div');
                preview.textContent = input.value;
                preview.style.fontFamily = fontName;
                preview.style.fontSize = '2rem';
                preview.style.border = '1px solid #ccc';
                preview.style.padding = '20px';
                preview.style.marginTop = '10px';

                // Update preview as user types
                input.addEventListener('input', () => {
                    preview.textContent = input.value;
                });

                previewContent.appendChild(input);
                previewContent.appendChild(preview);

                // Cleanup
                this.currentCleanup = () => {
                    // Remove input event listener
                    input.removeEventListener('input', () => {
                        preview.textContent = input.value;
                    });

                    // Clear DOM
                    previewContent.innerHTML = "";

                    // Remove style
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }

                    // Revoke font URL
                    URL.revokeObjectURL(fontUrl);
                };
            }



            renderBinaryContent(filePath, version = 0, maxBytes = 1024) {

                const previewContent = document.getElementById('previewContent');
                const fileName = filePath.split('/').pop();

                let abortController = new AbortController(); // for possible cancellation

                fetch(`/api/file/preview?path=${encodeURIComponent(filePath)}&version=${version}`, {
                    signal: abortController.signal
                })
                    .then(res => {
                        if (!res.ok) throw new Error('Failed to load file');
                        return res.arrayBuffer();
                    })
                    .then(buffer => {
                        const bytes = new Uint8Array(buffer);
                        const length = Math.min(bytes.length, maxBytes);

                        // Convert to hex + ASCII string
                        let hex = '';
                        for (let i = 0; i < length; i += 16) {
                            const row = bytes.slice(i, i + 16);
                            const hexBytes = Array.from(row).map(b => b.toString(16).padStart(2, '0')).join(' ');
                            const ascii = Array.from(row).map(b => (b >= 32 && b <= 126 ? String.fromCharCode(b) : '.')).join('');
                            hex += hexBytes.padEnd(16 * 3) + '  ' + ascii + '\n';
                        }

                        previewContent.innerHTML = `
<div class="bg-dark p-3 rounded" style="background-color: rgba(0,0,0,0.5); overflow: auto;">
    <pre style="color: #ffffff; font-family: monospace; margin: 0;">${hex}</pre>
    <p style="color: orange; font-size: 0.9rem; margin-top: 0.5rem;">
        ${fileName} — showing maximum ${length} byte(s)
    </p>
</div>`;
                    })
                    .catch(err => {
                        previewContent.innerHTML = `
<div class="bg-dark p-4 rounded text-center" 
     style="background-color: rgba(0,0,0,0.5); display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 1rem;">
    <div style="font-size: 4rem; color: orange;">&#9888;</div>
    <p style="color: orange; font-size: 1.2rem; margin: 0;">Cannot preview binary file</p>
    <p style="color: #ffffff; font-weight: bold; margin: 0;">${fileName}</p>
</div>`;
                        console.error(err);
                    });

                // Cleanup
                this.currentCleanup = () => {
                    // abort any ongoing fetch
                    abortController.abort();
                    previewContent.innerHTML = ""; // clear DOM
                    abortController = null;
                };
            }


            renderXACModel(xacData) {
                const previewContent = document.getElementById('previewContent');
                previewContent.classList.add("preview-xac");

                // Insert canvas
                previewContent.innerHTML = `
                    <div class="stat-card">
        <canvas id="glCanvas" class="rounded shadow" style="background:#111; display:block;"></canvas>
        </div>
    `;


                let canvas = document.getElementById('glCanvas');

                // Set actual canvas pixel size to match displayed size
                function resizeCanvas() {
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                }

                // Initial resize
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);


                canvas.addEventListener('mousemove', e => {
                    if (mouseDown) {
                        rotY -= (e.clientX - lastX) * 0.01;

                        // Update rotX with clamping
                        rotX += (e.clientY - lastY) * 0.01;
                        const maxRot = Math.PI / 2 - 0.01; // just below 90°
                        if (rotX > maxRot) rotX = maxRot;
                        if (rotX < -maxRot) rotX = -maxRot;

                        lastX = e.clientX;
                        lastY = e.clientY;
                    }
                });


                const gl = canvas.getContext('webgl');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);


                // --- Extract mesh data ---
                const positions = [], normals = [], colors = [], indices = [];

                function extractNode(node) {
                    if (!node) return;
                    if (node.model && node.model.submeshes) {
                        for (const sub of node.model.submeshes) {
                            const baseIndex = positions.length / 3;
                            // Positions
                            if (sub.positions && sub.positions.length > 0) {
                                for (let i = 0; i < sub.positions.length; i++) {
                                    const pos = sub.positions[i];
                                    positions.push(pos.x, pos.y, pos.z);

                                    if (sub.normals && sub.normals[i]) {
                                        const n = sub.normals[i];
                                        normals.push(n.x, n.y, n.z);
                                    } else normals.push(0, 0, 1);

                                    if (sub.colors && sub.colors[i]) {
                                        const c = sub.colors[i];
                                        colors.push(c.r ?? 1, c.g ?? 1, c.b ?? 1);
                                    } else colors.push(1.0, 0.6, 0.2);
                                }
                            }
                            // Indices
                            if (sub.indices && sub.indices.length > 0) {
                                for (const idx of sub.indices) indices.push(baseIndex + idx);
                            } else {
                                const vertCount = sub.positions ? sub.positions.length : 4;
                                for (let i = 0; i < vertCount; i++) indices.push(baseIndex + i);
                            }
                        }
                    }
                    if (node.children) for (const child of node.children) extractNode(child);
                }

                if (xacData.root_nodes && xacData.root_nodes.length > 0)
                    for (const root of xacData.root_nodes) extractNode(root);
                else {
                    positions.push(-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1);
                    normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1);
                    colors.push(1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0);
                    indices.push(0, 1, 2, 2, 3, 0);
                }

                // --- Compute bounding box ---
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i], y = positions[i + 1], z = positions[i + 2];
                    minX = Math.min(minX, x); minY = Math.min(minY, y); minZ = Math.min(minZ, z);
                    maxX = Math.max(maxX, x); maxY = Math.max(maxY, y); maxZ = Math.max(maxZ, z);
                }
                const centerX = (minX + maxX) / 2, centerY = (minY + maxY) / 2, centerZ = (minZ + maxZ) / 2;
                const sizeX = maxX - minX, sizeY = maxY - minY, sizeZ = maxZ - minZ;
                const maxSize = Math.max(sizeX, sizeY, sizeZ);
                let distance = maxSize * 1.5;

                // --- Interleave vertex data ---
                const vertexCount = positions.length / 3;
                const vertexData = new Float32Array(vertexCount * 9);
                for (let i = 0; i < vertexCount; i++) {
                    vertexData[i * 9 + 0] = positions[i * 3 + 0];
                    vertexData[i * 9 + 1] = positions[i * 3 + 1];
                    vertexData[i * 9 + 2] = positions[i * 3 + 2];
                    vertexData[i * 9 + 3] = normals[i * 3 + 0];
                    vertexData[i * 9 + 4] = normals[i * 3 + 1];
                    vertexData[i * 9 + 5] = normals[i * 3 + 2];
                    vertexData[i * 9 + 6] = colors[i * 3 + 0];
                    vertexData[i * 9 + 7] = colors[i * 3 + 1];
                    vertexData[i * 9 + 8] = colors[i * 3 + 2];
                }

                const indexArray = (vertexCount > 65535) ? new Uint32Array(indices) : new Uint16Array(indices);

                // --- Shaders ---
                const vsSource = `
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec3 aColor;
uniform mat4 uMVP;
varying vec3 vColor;

void main() {
    gl_Position = uMVP * vec4(aPosition,1.0);

    // Define 8 directional lights
    vec3 lightDirs[8];
    lightDirs[0] = normalize(vec3(1.0, 1.0, 1.0));
    lightDirs[1] = normalize(vec3(-1.0, 1.0, 1.0));
    lightDirs[2] = normalize(vec3(1.0, -1.0, 1.0));
    lightDirs[3] = normalize(vec3(-1.0, -1.0, 1.0));
    lightDirs[4] = normalize(vec3(1.0, 1.0, -1.0));
    lightDirs[5] = normalize(vec3(-1.0, 1.0, -1.0));
    lightDirs[6] = normalize(vec3(1.0, -1.0, -1.0));
    lightDirs[7] = normalize(vec3(-1.0, -1.0, -1.0));

    float diff = 0.0;
    for(int i=0; i<8; i++) {
        diff += max(dot(aNormal, lightDirs[i]), 0.0);
    }
    diff = diff / 4.0; // average contribution

    // Final color: ambient + diffuse
    vColor = aColor * diff + aColor * 0.2;
}
`;

                const fsSource = `
precision mediump float;
varying vec3 vColor;
void main() {
    gl_FragColor = vec4(vColor,1.0);
}
`;


                function compileShader(src, type) {
                    const s = gl.createShader(type);
                    gl.shaderSource(s, src);
                    gl.compileShader(s);
                    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
                    return s;
                }

                const vs = compileShader(vsSource, gl.VERTEX_SHADER);
                const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                gl.useProgram(program);

                const vbo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

                const ibo = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);

                const aPos = gl.getAttribLocation(program, 'aPosition');
                const aNormal = gl.getAttribLocation(program, 'aNormal');
                const aCol = gl.getAttribLocation(program, 'aColor');
                gl.enableVertexAttribArray(aPos);
                gl.enableVertexAttribArray(aNormal);
                gl.enableVertexAttribArray(aCol);
                const stride = 9 * 4;
                gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, stride, 0);
                gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, stride, 12);
                gl.vertexAttribPointer(aCol, 3, gl.FLOAT, false, stride, 24);

                const uMVP = gl.getUniformLocation(program, 'uMVP');

                function identity() { return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]); }
                function perspective(fov, aspect, near, far) {
                    const f = 1 / Math.tan(fov / 2), nf = 1 / (near - far);
                    return new Float32Array([
                        f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, (2 * far * near) * nf, 0
                    ]);
                }
                function multiply(a, b) {
                    const o = new Float32Array(16);
                    for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++)
                        o[j * 4 + i] = a[i] * b[j * 4] + a[i + 4] * b[j * 4 + 1] + a[i + 8] * b[j * 4 + 2] + a[i + 12] * b[j * 4 + 3];
                    return o;
                }
                function translate(m, x, y, z) { const t = identity(); t[12] = -x; t[13] = -y; t[14] = -z - distance; return multiply(m, t); }
                function rotateX(m, a) { const c = Math.cos(a), s = Math.sin(a); const r = identity(); r[5] = c; r[6] = s; r[9] = -s; r[10] = c; return multiply(m, r); }
                function rotateY(m, a) { const c = Math.cos(a), s = Math.sin(a); const r = identity(); r[0] = c; r[2] = s; r[8] = -s; r[10] = c; return multiply(m, r); }

                let rotX = 0, rotY = 0;
                let mouseDown = false, lastX = 0, lastY = 0;

                canvas.addEventListener('mousedown', e => { mouseDown = true; lastX = e.clientX; lastY = e.clientY; });
                canvas.addEventListener('mouseup', () => { mouseDown = false; });
                canvas.addEventListener('mousemove', e => {
                    if (mouseDown) { rotY -= (e.clientX - lastX) * 0.01; rotX += (e.clientY - lastY) * 0.01; lastX = e.clientX; lastY = e.clientY; }
                });
                canvas.addEventListener('wheel', e => {
                    // Prevent page scrolling
                    e.preventDefault();

                    // Zoom factor per wheel tick
                    const zoomSpeed = 1.02;

                    if (e.deltaY < 0) {
                        // Scroll up → zoom in
                        distance /= zoomSpeed;
                    } else {
                        // Scroll down → zoom out
                        distance *= zoomSpeed;
                    }

                    // Clamp distance to reasonable range
                    distance = Math.max(maxSize * 0.5, Math.min(maxSize * 10, distance));
                }, { passive: false });


                function render() {
                    resizeCanvas();
                    gl.clearColor(0.1, 0.1, 0.1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.enable(gl.DEPTH_TEST);

                    const proj = perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 30000);
                    let view = translate(identity(), centerX, centerY, centerZ);
                    view = rotateX(view, rotX);
                    view = rotateY(view, rotY);
                    const mvp = multiply(proj, view);

                    gl.uniformMatrix4fv(uMVP, false, mvp);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
                    gl.drawElements(gl.TRIANGLES, indexArray.length, vertexCount > 65535 ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT, 0);

                    requestAnimationFrame(render);
                }

                render();

            }

            renderIESTable(iesData) {
                const previewContent = document.getElementById('previewContent');

                if (!iesData.data || iesData.data.length === 0) {
                    previewContent.innerHTML = '<div class="text-light text-center p-4">No data available</div>';
                    return;
                }

                // Sort columns first by decl_idx, then by type_data
                let sortedColumn = [...iesData.columns]
                    .sort((a, b) => a.decl_idx - b.decl_idx)
                    .sort((a, b) => a.type_data - b.type_data);

                // Build headers
                const headers = sortedColumn
                    .map(col => col.name || col.column)
                    .filter(name => name.trim());

                let tableHTML = `
    <div class="ies-table">
        <div class="mb-3">
            <h4 class="text-center text-light">IES Filename : ${iesData.header.idspace}</h4>
            <small class="text-muted">
                Version: ${iesData.header.version} | 
                Fields: ${iesData.header.num_field} | 
                Columns: ${iesData.header.num_column}
            </small>
        </div>
        <div class="table-responsive" style="max-height:600px; overflow:auto;">
            <table class="table table-sm table-dark table-striped table-bordered align-middle text-center">
                <thead class="table-secondary text-dark sticky-top">
                    <tr>
                        <th scope="col" class="align-middle">Row Number</th>
                        <th scope="col" class="align-middle">Index Number</th>
                        <th scope="col" class="align-middle">Index</th>`;

                headers.forEach(header => {
                    tableHTML += `<th scope="col" class="align-middle">${header}</th>`;
                });

                tableHTML += `
                    </tr>
                </thead>
                <tbody>
    `;

                let numberRow = 1;
                iesData.data.forEach((row) => {
                    tableHTML += `<tr>
            <td>${numberRow}</td>
            <td>${row.index_data ?? ''}</td>
            <td>${row.row_text ? row.row_text.text_data : ''}</td>`;

                    if (row.floats) {
                        row.floats.forEach(f => {
                            tableHTML += `<td>${f.float_data}</td>`;
                        });
                    }

                    if (row.texts) {
                        row.texts.forEach(t => {
                            tableHTML += `<td>${t.text_data}</td>`;
                        });
                    }

                    tableHTML += `</tr>`;
                    numberRow++;
                });

                tableHTML += `
                </tbody>
            </table>
        </div>
    </div>
    `;

                previewContent.innerHTML = tableHTML;

                // Proper cleanup
                this.currentCleanup = () => {
                    previewContent.innerHTML = "";
                };
            }



            renderTextContent(text, filePath) {

                const previewContent = document.getElementById('previewContent');
                const extension = filePath.split('.').pop().toLowerCase();

                // Map extensions to Prism languages or plain text
                const extensionMap = {
                    // XML-like files
                    xml: 'markup',
                    skn: 'markup',
                    '3dprop': 'markup',
                    '3dworld': 'markup',
                    '3drender': 'markup',
                    '3deffect': 'markup',
                    sani: 'markup',
                    effect: 'markup',
                    atlas: 'markup',
                    sprbin: 'markup',
                    xsd: 'markup',

                    // C++ style files
                    x: 'cpp',
                    fx: 'glsl',
                    fxh: 'glsl',
                    export: 'cpp',

                    // JSON files
                    json: 'json',

                    // Lua files
                    lua: 'lua',

                    // Plain text
                    lst: 'none',
                    txt: 'none',
                };

                const prismLang = extensionMap[extension] || 'none';

                previewContent.innerHTML = `
        <div class="bg-dark p-3 rounded" 
             style="background-color: rgba(0,0,0,0.5) !important; max-height: 500px; overflow:auto;">
            <pre style="color: #ffffff; margin: 0; white-space: pre-wrap; word-wrap: break-word;">
                <code class="${prismLang !== 'none' ? 'language-' + prismLang : ''}">
${this.escapeHtml(text)}
                </code>
            </pre>
        </div>
    `;

                // Apply Prism highlighting if language is not plain text
                if (window.Prism && prismLang !== 'none') {
                    Prism.highlightAllUnder(previewContent);
                }

                // Proper cleanup
                this.currentCleanup = () => {
                    previewContent.innerHTML = "";
                };
            }


            renderMP3Audio(blob) {

                const previewContent = document.getElementById('previewContent');
                const audioUrl = URL.createObjectURL(blob);

                previewContent.innerHTML = `
        <div class="stat-card">
            <div class="text-center">
                <audio controls class="w-100 mt-3 shadow rounded">
                    <source src="${audioUrl}" type="${blob.type || 'audio/mpeg'}">
                    Your browser does not support the audio element.
                </audio>
            </div>
        </div>
    `;

                // Add debug info
                const debugInfo = document.createElement('div');
                debugInfo.className = 'mt-3 p-3';
                debugInfo.style.background = 'rgba(255, 255, 255, 0.05)';
                debugInfo.style.borderRadius = '8px';
                debugInfo.style.fontSize = '0.85rem';
                debugInfo.innerHTML = `
        <div class="text-light">
            <strong>Audio Debug Information:</strong><br>
            <span style="color: #4a90e2;">Format:</span> ${blob.type || 'Unknown'}<br>
            <span style="color: #4a90e2;">File Size:</span> ${this.formatBytes(blob.size)}<br>
            <span style="color: #4a90e2;">Duration:</span> <span id="audioDuration">Loading...</span>
        </div>
    `;
                previewContent.appendChild(debugInfo);

                // Get audio element and load metadata
                const audioElement = previewContent.querySelector('audio');
                audioElement.onloadedmetadata = () => {
                    const durationElem = document.getElementById('audioDuration');
                    durationElem.textContent = this.formatTime(audioElement.duration);
                };

                // Cleanup
                this.currentCleanup = () => {
                    if (audioElement) {
                        audioElement.pause();
                        audioElement.src = "";
                    }
                    URL.revokeObjectURL(audioUrl);
                    previewContent.innerHTML = ""; // clear DOM
                };
            }

            // Helper to format seconds into mm:ss
            formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }



            renderImageContent(blob) {

                const previewContent = document.getElementById('previewContent');
                const imageUrl = URL.createObjectURL(blob);

                let img = new Image();

                img.onload = () => {
                    previewContent.innerHTML = `
            <div class="stat-card">
                <div class="text-center">
                    <img src="${imageUrl}" class="img-fluid rounded shadow" style="max-height: 70vh;" alt="Preview">
                </div>
            </div>
        `;

                    // Debug info
                    const debugInfo = document.createElement('div');
                    debugInfo.className = 'mt-3 p-3';
                    debugInfo.style.background = 'rgba(255, 255, 255, 0.05)';
                    debugInfo.style.borderRadius = '8px';
                    debugInfo.style.fontSize = '0.85rem';
                    debugInfo.innerHTML = `
            <div class="text-light">
                <strong>Image Debug Information:</strong><br>
                <span style="color: #4a90e2;">Dimensions:</span> ${img.naturalWidth} x ${img.naturalHeight}<br>
                <span style="color: #4a90e2;">Format:</span> ${blob.type || 'Unknown'}<br>
                <span style="color: #4a90e2;">File Size:</span> ${this.formatBytes(blob.size)}<br>
                <span style="color: #4a90e2;">Aspect Ratio:</span> ${(img.naturalWidth / img.naturalHeight).toFixed(3)}
            </div>
        `;
                    previewContent.appendChild(debugInfo);
                };

                img.onerror = () => {
                    previewContent.innerHTML = `
            <div class="text-center text-danger p-4">
                <i class="bi bi-exclamation-triangle" style="font-size: 3rem;"></i>
                <h5 class="mt-3">Error Loading Image</h5>
                <p>Failed to decode image format</p>
            </div>
        `;
                };

                img.src = imageUrl;

                // Cleanup
                this.currentCleanup = () => {
                    if (img) {
                        img.src = ""; // release image reference
                        img = null;
                    }
                    URL.revokeObjectURL(imageUrl);
                    previewContent.innerHTML = ""; // clear preview
                };
            }



            renderDDSContent(arrayBuffer) {

                const previewContent = document.getElementById('previewContent');

                // Hold references for cleanup
                let canvas = null;
                let gl = null;
                let texture = null;
                let buf = null;
                let vs = null;
                let fs = null;
                let prog = null;

                try {
                    const DDS_MAGIC = 0x20534444; // "DDS "
                    const DDS_DX10 = 0x30315844; // "DX10"

                    if (arrayBuffer.byteLength < 128) throw new Error('Invalid DDS file size');

                    const dds = new DataView(arrayBuffer);
                    const magic = dds.getUint32(0, true);
                    if (magic !== DDS_MAGIC) throw new Error('Invalid DDS header');

                    const height = dds.getUint32(12, true);
                    const width = dds.getUint32(16, true);
                    const fourCC = dds.getUint32(84, true);
                    let offset = 128;
                    let format = null;
                    let blockSize = 0;
                    let uncompressed = false;
                    let bytesPerPixel = 4; // default RGBA

                    // DX10 header
                    if (fourCC === DDS_DX10) {
                        if (arrayBuffer.byteLength < offset + 20) throw new Error('Invalid DDS DX10 file');
                        const dxgiFormat = dds.getUint32(offset, true);
                        offset += 20;

                        switch (dxgiFormat) {
                            case 71: format = 'COMPRESSED_RGBA_S3TC_DXT1_EXT'; blockSize = 8; break;
                            case 74: format = 'COMPRESSED_RGBA_S3TC_DXT3_EXT'; blockSize = 16; break;
                            case 77: format = 'COMPRESSED_RGBA_S3TC_DXT5_EXT'; blockSize = 16; break;
                            default: throw new Error('Unsupported DX10 DDS format');
                        }
                    } else {
                        // Legacy
                        switch (fourCC) {
                            case 0x31545844: format = 'COMPRESSED_RGBA_S3TC_DXT1_EXT'; blockSize = 8; break; // DXT1
                            case 0x33545844: format = 'COMPRESSED_RGBA_S3TC_DXT3_EXT'; blockSize = 16; break; // DXT3
                            case 0x35545844: format = 'COMPRESSED_RGBA_S3TC_DXT5_EXT'; blockSize = 16; break; // DXT5
                            case 0: // uncompressed
                                format = 'UNCOMPRESSED';
                                uncompressed = true;
                                bytesPerPixel = dds.getUint32(88, true) / 8; // dwRGBBitCount
                                break;
                            default:
                                throw new Error('Unsupported legacy DDS format');
                        }
                    }

                    // Setup canvas
                    canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    canvas.style.maxWidth = '100%';
                    canvas.style.maxHeight = '70vh';
                    canvas.style.display = 'block';
                    canvas.style.margin = '0 auto';
                    canvas.style.border = '1px solid #333';
                    previewContent.innerHTML = '';
                    previewContent.appendChild(canvas);

                    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!gl) throw new Error('WebGL not supported');

                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                    texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);

                    if (uncompressed) {
                        const pixelData = new Uint8Array(arrayBuffer, offset, width * height * bytesPerPixel);
                        gl.texImage2D(
                            gl.TEXTURE_2D,
                            0,
                            bytesPerPixel === 4 ? gl.RGBA : gl.RGB,
                            width,
                            height,
                            0,
                            bytesPerPixel === 4 ? gl.RGBA : gl.RGB,
                            gl.UNSIGNED_BYTE,
                            pixelData
                        );
                    } else {
                        const ext = gl.getExtension('WEBGL_compressed_texture_s3tc') ||
                            gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                            gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                        if (!ext) throw new Error('S3TC compression not supported');

                        const formatMap = {
                            'COMPRESSED_RGBA_S3TC_DXT1_EXT': ext.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                            'COMPRESSED_RGBA_S3TC_DXT3_EXT': ext.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                            'COMPRESSED_RGBA_S3TC_DXT5_EXT': ext.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        };

                        const glFormat = formatMap[format];
                        const imageSize = Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * blockSize;
                        const textureData = new Uint8Array(arrayBuffer, offset, imageSize);
                        gl.compressedTexImage2D(gl.TEXTURE_2D, 0, glFormat, width, height, 0, textureData);
                    }

                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    // Shaders
                    vs = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(vs, `
            attribute vec2 pos;
            attribute vec2 uv;
            varying vec2 vUV;
            void main() {
                vUV = uv;
                gl_Position = vec4(pos, 0.0, 1.0);
            }
        `);
                    gl.compileShader(vs);

                    fs = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(fs, `
            precision mediump float;
            varying vec2 vUV;
            uniform sampler2D tex;
            void main() {
                gl_FragColor = texture2D(tex, vUV);
            }
        `);
                    gl.compileShader(fs);

                    prog = gl.createProgram();
                    gl.attachShader(prog, vs);
                    gl.attachShader(prog, fs);
                    gl.linkProgram(prog);
                    gl.useProgram(prog);

                    const verts = new Float32Array([
                        -1, -1, 0, 1,
                        1, -1, 1, 1,
                        -1, 1, 0, 0,
                        1, 1, 1, 0
                    ]);
                    buf = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                    gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);

                    const posLoc = gl.getAttribLocation(prog, 'pos');
                    const uvLoc = gl.getAttribLocation(prog, 'uv');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
                    gl.enableVertexAttribArray(uvLoc);
                    gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 16, 8);

                    gl.uniform1i(gl.getUniformLocation(prog, 'tex'), 0);

                    gl.viewport(0, 0, width, height);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    // Debug Info
                    const debugInfo = document.createElement('div');
                    debugInfo.className = 'mt-3 p-3';
                    debugInfo.style.background = 'rgba(255, 255, 255, 0.05)';
                    debugInfo.style.borderRadius = '8px';
                    debugInfo.style.fontSize = '0.85rem';
                    debugInfo.innerHTML = `
            <div class="text-light">
                <strong>DDS Debug Information:</strong><br>
                <span style="color: #FFA500;">Dimensions:</span> ${width} x ${height}<br>
                <span style="color: #FFA500;">Format:</span> ${format}<br>
                ${uncompressed
                            ? `<span style="color: #FFA500;">Bytes Per Pixel:</span> ${bytesPerPixel}<br>`
                            : `<span style="color: #FFA500;">Block Size:</span> ${blockSize} bytes<br>`}
                <span style="color: #FFA500;">Data Offset:</span> ${offset} bytes<br>
                <span style="color: #FFA500;">Total File Size:</span> ${arrayBuffer.byteLength} bytes<br>
                <span style="color: #FFA500;">FourCC:</span> 0x${fourCC.toString(16).toUpperCase()}<br>
                <span style="color: #FFA500;">Header Type:</span> ${fourCC === DDS_DX10 ? 'DX10 Extended' : 'Legacy'}
            </div>
        `;
                    previewContent.appendChild(debugInfo);

                } catch (error) {
                    previewContent.innerHTML = `
            <div class="text-center text-danger p-4">
                <i class="bi bi-exclamation-triangle" style="font-size: 3rem;"></i>
                <h5 class="mt-3">Error Loading DDS</h5>
                <p>${error.message}</p>
            </div>
        `;
                }

                // Cleanup function
                this.currentCleanup = () => {
                    if (gl) {
                        if (texture) gl.deleteTexture(texture);
                        if (buf) gl.deleteBuffer(buf);
                        if (vs) gl.deleteShader(vs);
                        if (fs) gl.deleteShader(fs);
                        if (prog) gl.deleteProgram(prog);

                        gl.getExtension('WEBGL_lose_context')?.loseContext();
                    }

                    if (canvas && canvas.parentNode) {
                        canvas.parentNode.removeChild(canvas);
                    }

                    // Nullify refs
                    canvas = gl = texture = buf = vs = fs = prog = null;
                };
            }



            async searchFiles(query) {
                if (!query.trim()) {
                    this.loadRootFolders();
                    return;
                }

                try {
                    const response = await fetch(`/api/file/search?file_name=${encodeURIComponent(query)}`);
                    if (!response.ok) throw new Error('Search failed');

                    const data = await response.json();
                    this.renderSearchResults(data);
                } catch (error) {
                    console.error('Search error:', error);
                }
            }

            renderSearchResults(searchData) {
                const container = document.getElementById('fileTree');
                container.innerHTML = '';

                if (searchData.found_files.length === 0) {
                    container.innerHTML = `
                        <div class="text-light p-3">
                            <i class="bi bi-search"></i>
                            No files found matching "${searchData.file_name}"
                        </div>
                    `;
                    return;
                }

                // Group files by unique path, keeping all versions
                const groupedFiles = new Map();
                searchData.found_files.forEach(file => {
                    const key = file.file_path;
                    if (!groupedFiles.has(key)) {
                        groupedFiles.set(key, []);
                    }
                    groupedFiles.get(key).push(file);
                });

                const header = document.createElement('div');
                header.className = 'p-3 border-bottom';
                header.innerHTML = `
                    <small class="text-light">
                        Found ${groupedFiles.size} unique file(s) (${searchData.found_files.length} total versions) for "${searchData.file_name}"
                    </small>
                `;
                container.appendChild(header);

                // Sort grouped files by path case-insensitively
                const sortedEntries = Array.from(groupedFiles.entries()).sort((a, b) =>
                    a[0].toLowerCase().localeCompare(b[0].toLowerCase())
                );

                sortedEntries.forEach(([filePath, versions]) => {
                    const element = document.createElement('div');
                    element.className = 'tree-item file';

                    const fileName = filePath.split('/').pop();
                    const ext = fileName.split('.').pop().toLowerCase();
                    const iconClass = this.getFileIcon(ext);

                    element.innerHTML = `
                        <i class="bi ${iconClass} file-icon ${ext}"></i>
                        <div style="flex: 1;">
                            <div class="text-light">${fileName}</div>
                            <small class="text-light">${filePath} (${versions.length} version${versions.length > 1 ? 's' : ''})</small>
                        </div>
                    `;

                    element.addEventListener('click', async () => {
                        document.querySelectorAll('.tree-item.selected').forEach(item => {
                            item.classList.remove('selected');
                        });
                        element.classList.add('selected');

                        await this.loadFileInfo(filePath);
                    });

                    container.appendChild(element);
                });
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }
        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ArchiveViewer();
        });

        // Handle panel resizing
        document.addEventListener('DOMContentLoaded', () => {
            const panels = document.querySelectorAll('.tree-panel, .info-panel');

            panels.forEach(panel => {
                let isResizing = false;

                panel.addEventListener('mousedown', (e) => {
                    if (e.offsetX > panel.offsetWidth - 10) {
                        isResizing = true;
                        document.body.style.cursor = 'col-resize';
                        e.preventDefault();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (isResizing) {
                        const newWidth = e.clientX - panel.offsetLeft;
                        if (newWidth >= 250 && newWidth <= 500) {
                            panel.style.width = newWidth + 'px';
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = 'default';
                    }
                });
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+F for search
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                document.getElementById('fileSearch').focus();
            }

            // Escape to clear search
            if (e.key === 'Escape') {
                const searchInput = document.getElementById('fileSearch');
                if (searchInput === document.activeElement) {
                    searchInput.value = '';
                    searchInput.blur();
                    window.archiveViewer?.loadRootFolders();
                }
            }
        });
    </script>
</body>

</html>